<!DOCTYPE html>
<html lang="de" class="">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digitale Bildverarbeitung - Lernkarten</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"
        xintegrity="sha384-n8MVd4RsNIU0KOVEMmg9rtabNEJFvGzMGNKjyDuHcH4+PSDrUcN6qMZpaodpcxMil" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"
        xintegrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
        xintegrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
        crossorigin="anonymous"></script>

    <script>
        // Tailwind dark mode configuration
        tailwind.config = {
            darkMode: 'class',
        }
    </script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .dark body {
            background-color: #111827;
        }

        .flashcard-container {
            perspective: 1000px;
        }

        .flashcard {
            width: 100%;
            height: 100%;
            position: relative;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }

        .flashcard.is-flipped {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            border-radius: 1rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            border: 1px solid rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            overflow: hidden; /* Important for containing positioned elements */
        }

        .card-front {
            background-color: #ffffff;
            color: #1f2937;
            justify-content: center;
        }

        .dark .card-front {
            background-color: #1f2937;
            color: #f9fafb;
            border-color: #374151;
        }

        .card-back {
            background-color: #f9fafb;
            color: #111827;
            transform: rotateY(180deg);
            justify-content: space-between;
        }

        .dark .card-back {
            background-color: #253041;
            color: #d1d5db;
            border-color: #374151;
        }
        
        .card-content-wrapper {
             padding: 2.5rem 1.5rem; /* Increased top/bottom padding to avoid button overlap */
             padding-bottom: 5rem; /* Extra padding at the bottom for floating buttons */
             width: 100%;
             height: 100%;
             overflow-y: auto;
             flex-grow: 1;
        }
        
        .card-front .card-content-wrapper {
             display: flex;
             justify-content: center;
             align-items: center;
        }

        .level-indicator {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 10;
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 600;
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.25);
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .dark .level-indicator {
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        .level-indicator.level-normal {
            background: rgba(79, 70, 229, 0.6); /* Indigo */
        }
        .level-indicator.level-ai {
            background: rgba(37, 99, 235, 0.6); /* Blue */
        }
        
        /* Glassmorphism Button Style */
        .read-aloud-btn {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 10;
            background: rgba(255, 255, 255, 0.5);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: background 0.2s ease;
        }
        .dark .read-aloud-btn {
            background: rgba(31, 41, 55, 0.5); /* #1f2937 with alpha */
             border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .read-aloud-btn:hover {
            background: rgba(255, 255, 255, 0.7);
        }
        .dark .read-aloud-btn:hover {
            background: rgba(31, 41, 55, 0.7);
        }
        
        .stats-controls-container {
            display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center; align-items: center;
        }
        .stat-box {
            background-color: white; padding: 0.5rem 1rem; border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            font-size: 0.875rem; color: #4b5563; cursor: pointer; transition: all 0.2s;
        }
        .dark .stat-box { background-color: #374151; color: #d1d5db; }
        .stat-box:hover { transform: translateY(-2px); box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); }
        .stat-box.active { background-color: #4f46e5; color: white; }
        .dark .stat-box.active { background-color: #6366f1; color: white; }

        .control-btn {
            background-color: #6b7280; color: white; padding: 0.5rem 1rem; border-radius: 0.5rem;
            font-size: 0.875rem; font-weight: 600; cursor: pointer; transition: all 0.2s;
        }
        .control-btn:disabled { opacity: 0.6; cursor: not-allowed; background-color: #9ca3af; }
        .control-btn:hover:not(:disabled) {
            background-color: #4b5563; transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .dark .control-btn { background-color: #4b5563; }
        .dark .control-btn:disabled { background-color: #374151; }
        .dark .control-btn:hover:not(:disabled) { background-color: #374151; }

        .nav-button-bottom {
            background-color: white; color: #4b5563; border: 1px solid #d1d5db; padding: 0.5rem 1.5rem;
            border-radius: 0.5rem; font-weight: 600; cursor: pointer; transition: all 0.2s;
        }
        .dark .nav-button-bottom { background-color: #374151; color: #d1d5db; border-color: #4b5563; }
        .nav-button-bottom:disabled { opacity: 0.5; cursor: not-allowed; }
        .nav-button-bottom:hover:not(:disabled) {
            background-color: #f3f4f6; border-color: #9ca3af; transform: translateY(-2px);
            box-shadow: 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .dark .nav-button-bottom:hover:not(:disabled) { background-color: #4b5563; border-color: #6b7280; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5);
            display: flex; align-items: center; justify-content: center; z-index: 50;
            opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        .modal-content {
            background: white; padding: 2rem; border-radius: 1rem; width: 90%; max-width: 500px;
            transform: scale(0.95); transition: transform 0.3s ease; position: relative;
        }
        .modal-overlay.visible .modal-content { transform: scale(1); }
        .dark .modal-content { background-color: #1f2937; }
        .modal-close-btn {
            position: absolute; top: 1rem; right: 1rem; background: none; border: none; padding: 0.5rem;
            cursor: pointer; color: #6b7280; border-radius: 9999px;
        }
        .modal-close-btn:hover { color: #111827; background-color: #e5e7eb; }
        .dark .modal-close-btn { color: #9ca3af; }
        .dark .modal-close-btn:hover { color: #f9fafb; background-color: #4b5563; }
        
        .custom-slider {
            -webkit-appearance: none; appearance: none; width: 100%; height: 6px;
            background: #e5e7eb; border-radius: 9999px; outline: none; padding: 0; margin: 0;
        }
        .dark .custom-slider { background: #374151; }
        .custom-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px; background: #4f46e5;
            cursor: pointer; border-radius: 50%; border: 3px solid #ffffff;
            box-shadow: 0 0 0 2px #cbd5e1; transition: all 0.2s ease;
        }
        .dark .custom-slider::-webkit-slider-thumb { border: 3px solid #1f2937; box-shadow: 0 0 0 2px #4b5563; }
        .custom-slider::-webkit-slider-thumb:hover { background: #6366f1; transform: scale(1.1); }
        
        ::-webkit-scrollbar { width: 12px; height: 12px; }
        ::-webkit-scrollbar-track { background: #f1f5f9; border-radius: 6px; }
        ::-webkit-scrollbar-thumb { background: linear-gradient(180deg, #64748b, #475569); border-radius: 6px; border: 2px solid #f1f5f9; }
        .dark ::-webkit-scrollbar-track { background: #1f2937; }
        .dark ::-webkit-scrollbar-thumb { background: linear-gradient(180deg, #4b5563, #374151); border: 2px solid #1f2937; }
        .card-content-wrapper, .modal-content, #explanation-content { scrollbar-width: thin; scrollbar-color: #64748b #f1f5f9; }
        .dark .card-content-wrapper, .dark .modal-content, .dark #explanation-content { scrollbar-color: #4b5563 #1f2937; }
        
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1); width: 36px; height: 36px; border-radius: 50%;
            border-left-color: #4f46e5; animation: spin 1s ease infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Iframe-specific adjustments */
        :root {
            --iframe-mode: 0;
        }
        
        .iframe-adjusted {
            padding-top: calc(1rem + var(--iframe-mode) * 0rem);
        }
        
        .settings-controls-iframe {
            top: calc(1rem + var(--iframe-mode) * 0.5rem);
        }
        
        /* Make sure the page works well in iframe */
        body.iframe-mode {
            padding: 1rem;
        }
        
        .iframe-mode .absolute.top-4.right-4 {
            top: 1rem;
            right: 1rem;
        }
    </style>
</head>

<body class="flex flex-col items-center min-h-screen p-4 sm:p-6 lg:p-8">
    
    <div id="api-key-banner" class="hidden fixed top-0 left-0 right-0 bg-yellow-100 dark:bg-yellow-900 border-b border-yellow-400 dark:border-yellow-700 text-yellow-800 dark:text-yellow-200 px-4 py-3 shadow-md z-40" role="alert">
      <div class="flex items-center justify-center max-w-4xl mx-auto">
        <div class="py-1"><svg class="fill-current h-6 w-6 text-yellow-500 mr-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zM9 5v6h2V5H9zm0 8v2h2v-2H9z"/></svg></div>
        <div>
          <p class="font-bold">Aktivieren Sie die AI-Funktionen!</p>
          <p class="text-sm">Um Karten zu generieren, Erklärungen zu erhalten und die AI-Stimme zu nutzen, <button id="banner-settings-link" class="font-semibold underline">fügen Sie Ihren Google API-Schlüssel in den Einstellungen hinzu</button>.</p>
        </div>
        <button id="close-api-banner" class="ml-auto -mx-1.5 -my-1.5 bg-yellow-100 dark:bg-yellow-900 text-yellow-500 rounded-lg focus:ring-2 focus:ring-yellow-400 p-1.5 hover:bg-yellow-200 dark:hover:bg-yellow-800 inline-flex h-8 w-8" aria-label="Dismiss">
            <span class="sr-only">Dismiss</span>
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>
        </button>
      </div>
    </div>


    <!-- Settings and Theme Toggle - adjusted for iframe -->
    <div class="absolute top-4 right-4 flex items-center gap-2 z-30 settings-controls-iframe">
        <button id="settings-btn" class="p-2 rounded-full text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
        </button>
        <button id="theme-toggle" class="p-2 rounded-full text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none">
            <svg id="theme-toggle-dark-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg>
            <svg id="theme-toggle-light-icon" class="w-6 h-6 hidden" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.707.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM10 16a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM3.05 4.343a1 1 0 011.414 0l.707.707a1 1 0 01-1.414 1.414l-.707-.707a1 1 0 010-1.414zm1.414 10.607a1 1 0 010-1.414l.707-.707a1 1 0 111.414 1.414l-.707.707a1 1 0 01-1.414 0zM16.95 5.657a1 1 0 01-1.414 0l-.707-.707a1 1 0 011.414-1.414l.707.707a1 1 0 010 1.414z"></path></svg>
        </button>
    </div>

    <div id="reset-modal" class="modal-overlay">
        <div class="modal-content text-center">
            <h2 id="reset-modal-title" class="text-2xl font-bold mb-4 text-gray-900 dark:text-gray-100">Fortschritt zurücksetzen</h2>
            <p id="reset-modal-text" class="text-gray-600 dark:text-gray-300 mb-6">Möchtest du den Lernfortschritt wirklich zurücksetzen?</p>
            <div class="flex justify-center gap-4">
                <button id="reset-cancel-btn" class="px-6 py-2 bg-gray-200 dark:bg-gray-600 text-gray-800 dark:text-gray-200 font-semibold rounded-lg shadow hover:bg-gray-300 dark:hover:bg-gray-500 transition-all">Abbrechen</button>
                <button id="reset-confirm-btn" class="px-6 py-2 bg-red-600 text-white font-semibold rounded-lg shadow hover:bg-red-700 transition-all">Zurücksetzen</button>
            </div>
        </div>
    </div>
    
    <div id="delete-modal" class="modal-overlay">
        <div class="modal-content text-center">
            <h2 class="text-2xl font-bold mb-4 text-gray-900 dark:text-gray-100">Karte löschen</h2>
            <p class="text-gray-600 dark:text-gray-300 mb-6">Möchtest du diese Karte wirklich endgültig löschen?</p>
            <div class="flex justify-center gap-4">
                <button id="delete-cancel-btn" class="px-6 py-2 bg-gray-200 dark:bg-gray-600 text-gray-800 dark:text-gray-200 font-semibold rounded-lg shadow hover:bg-gray-300 dark:hover:bg-gray-500 transition-all">Abbrechen</button>
                <button id="delete-confirm-btn" class="px-6 py-2 bg-red-600 text-white font-semibold rounded-lg shadow hover:bg-red-700 transition-all">Löschen</button>
            </div>
        </div>
    </div>
    
    <div id="settings-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="border-b border-gray-200 dark:border-gray-700 pb-6 mb-6">
                <h2 class="text-2xl font-bold mb-4 text-gray-900 dark:text-gray-100 text-center">AI-Einstellungen</h2>
                <div class="space-y-4">
                    <div>
                        <label for="api-key-input" class="block mb-2 text-sm font-medium text-gray-900 dark:text-gray-300">Google AI API Schlüssel</label>
                        <div class="flex gap-2">
                             <input type="password" id="api-key-input" class="flex-grow bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-indigo-500 focus:border-indigo-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white" placeholder="Deinen Schlüssel hier einfügen">
                             <button id="api-key-save-btn" class="px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow hover:bg-indigo-700 transition-all">Speichern</button>
                        </div>
                         <div id="api-key-status" class="text-xs text-center mt-2 h-4"></div>
                         <p class="text-xs text-gray-500 dark:text-gray-400 mt-2">
                            Dein Schlüssel wird sicher in deinem Browser gespeichert.
                            <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-indigo-600 hover:underline dark:text-indigo-400">Hier einen neuen Schlüssel erstellen</a>.
                        </p>
                    </div>
                </div>
            </div>
            <h2 class="text-2xl font-bold mb-6 text-gray-900 dark:text-gray-100 text-center">Audio-Einstellungen</h2>
            <div class="space-y-6">
                <div>
                    <label for="rate-slider" class="block mb-2 text-sm font-medium text-gray-900 dark:text-gray-300">Geschwindigkeit: <span id="rate-value">1</span></label>
                    <input id="rate-slider" type="range" min="0.5" max="2" step="0.1" value="1" class="custom-slider">
                </div>
                <div>
                    <label for="pitch-slider" class="block mb-2 text-sm font-medium text-gray-900 dark:text-gray-300">Tonhöhe: <span id="pitch-value">1</span></label>
                    <input id="pitch-slider" type="range" min="0" max="2" step="0.1" value="1" class="custom-slider">
                </div>
                <div class="flex items-center">
                    <input id="auto-read-checkbox" type="checkbox" value="" class="w-4 h-4 text-indigo-600 bg-gray-100 border-gray-300 rounded focus:ring-indigo-500 dark:focus:ring-indigo-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                    <label for="auto-read-checkbox" class="ml-2 text-sm font-medium text-gray-900 dark:text-gray-300">Karten automatisch vorlesen</label>
                </div>
                <p class="text-xs text-gray-500 dark:text-gray-400">Die AI-Stimme wird automatisch verwendet, wenn ein API-Schlüssel hinterlegt ist. Die Einstellungen hier gelten für die Standard-Browserstimme.</p>
            </div>
             <div class="flex justify-center mt-8">
                <button id="settings-close-btn" class="px-6 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow hover:bg-indigo-700 transition-all">Schließen</button>
            </div>
        </div>
    </div>
    
    <div id="explanation-modal" class="modal-overlay">
        <div class="modal-content max-h-[80vh] flex flex-col">
             <button id="explanation-close-btn-top" class="modal-close-btn">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
             </button>
             <h2 class="text-2xl font-bold mb-4 text-gray-900 dark:text-gray-100">Einfach erklärt</h2>
             <div id="explanation-content" class="text-gray-700 dark:text-gray-300 space-y-4 overflow-y-auto flex-grow"></div>
             <div class="flex justify-center mt-6 flex-shrink-0">
                 <button id="explanation-close-btn-bottom" class="px-6 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow hover:bg-indigo-700 transition-all">Schließen</button>
             </div>
        </div>
    </div>

    <div id="generate-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-6 text-gray-900 dark:text-gray-100">Neue Karten generieren</h2>
            <div class="space-y-4">
                <div>
                    <label for="topic-input" class="block mb-2 text-sm font-medium text-gray-900 dark:text-gray-300">Thema</label>
                    <input type="text" id="topic-input" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-indigo-500 focus:border-indigo-500 block w-full p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white" placeholder="z.B. Fourier-Transformation">
                </div>
                 <button id="suggest-topic-btn" class="w-full px-4 py-2 text-sm font-medium text-indigo-600 bg-indigo-100 dark:bg-indigo-900 dark:text-indigo-200 rounded-lg hover:bg-indigo-200 dark:hover:bg-indigo-800 transition-all">Thema vorschlagen</button>
            </div>
             <div id="generation-status" class="mt-4 text-center"></div>
             <div class="flex justify-center gap-4 mt-8">
                <button id="generate-cancel-btn" class="px-6 py-2 bg-gray-200 dark:bg-gray-600 text-gray-800 dark:text-gray-200 font-semibold rounded-lg shadow hover:bg-gray-300 dark:hover:bg-gray-500 transition-all">Abbrechen</button>
                <button id="generate-confirm-btn" class="px-6 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow hover:bg-indigo-700 transition-all flex items-center gap-2">
                    <span id="generate-btn-text">Generieren</span>
                    <div id="generate-spinner" class="spinner w-5 h-5 border-2 hidden"></div>
                </button>
            </div>
        </div>
    </div>

    <!-- Main Content Container with iframe adjustments -->
    <div class="w-full max-w-4xl mx-auto pt-8 iframe-adjusted">
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold text-gray-800 dark:text-gray-100 mb-2">
                Lernkarten: Digitale Bildverarbeitung
            </h1>
            <p class="text-gray-600 dark:text-gray-400 text-lg">
                Klicke auf eine Karte, um die Antwort zu sehen. Bewerte sie danach.
            </p>
        </header>
        <div class="w-full max-w-2xl mx-auto mb-6">
            <div class="flex gap-2">
                <div class="relative flex-grow">
                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                        <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                    </div>
                    <input type="search" id="search-input" placeholder="Frage oder Thema suchen..." class="block w-full pl-10 pr-10 py-2.5 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-indigo-500 dark:focus:border-indigo-500">
                    <button id="clear-search-btn" class="absolute inset-y-0 right-0 pr-3 flex items-center cursor-pointer hidden">
                        <svg class="w-5 h-5 text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                </div>
                 <button id="open-generate-modal-btn" title="Neue Karten generieren" class="flex-shrink-0 p-2.5 bg-indigo-600 text-white rounded-lg shadow-sm hover:bg-indigo-700 transition-all">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707m12.728 0l-.707.707M12 21v-1m0-10a3 3 0 013 3 3 3 0 01-3 3 3 3 0 01-3-3 3 3 0 013-3z"></path></svg>
                 </button>
            </div>
        </div>

        <div id="stats-container" class="mb-6 text-center"></div>

        <main class="flex flex-col items-center">
            <div id="flashcard-container" class="flashcard-container w-full h-[500px] sm:h-[450px] relative"></div>
            <div id="navigation-container" class="w-full max-w-lg flex justify-between items-center my-4">
                <button id="prev-btn" class="nav-button-bottom"> &lt; Zurück </button>
                <span id="card-counter" class="text-sm font-medium text-gray-600 dark:text-gray-400"></span>
                <button id="next-btn" class="nav-button-bottom"> Weiter &gt; </button>
            </div>

            <div id="answer-buttons" class="flex justify-center items-center gap-4 w-full mt-2">
                <button id="wrong-btn" class="group px-6 py-4 bg-gradient-to-br from-red-500 to-red-700 text-white font-bold rounded-xl shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-red-400 dark:focus:ring-red-800 transition-all text-lg w-1/2 max-w-xs transform hover:-translate-y-1">
                    <span class="flex items-center justify-center">
                        <svg class="w-6 h-6 mr-2 transition-transform group-hover:scale-110" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>Falsch
                    </span>
                </button>
                <button id="correct-btn" class="group px-6 py-4 bg-gradient-to-br from-green-500 to-green-700 text-white font-bold rounded-xl shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-green-400 dark:focus:ring-green-800 transition-all text-lg w-1/2 max-w-xs transform hover:-translate-y-1">
                    <span class="flex items-center justify-center">
                        <svg class="w-6 h-6 mr-2 transition-transform group-hover:scale-110" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>Richtig
                    </span>
                </button>
            </div>
        </main>
    </div>

    <script>
        const STORAGE_KEY = 'db-flashcards-progress_v3';
        const AI_CARDS_KEY = 'db-flashcards-ai-cards_v1';
        const THEME_KEY = 'db-flashcards-theme';
        const SETTINGS_KEY = 'db-flashcards-settings_v1';
        const API_KEY_STORAGE_KEY = 'db-flashcards-google-api-key_v2';

        const initialCardContent = {
           "q1": {
                question: "1. Wofür sind Ortsrasterung und Intensitätsrasterung gut und wie funktionieren sie?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Ortsrasterung & Intensitätsrasterung</h3><p class="mb-4">Beide Prozesse sind grundlegend für die <strong class="highlight">Digitalisierung eines Bildes</strong>. Sie wandeln eine kontinuierliche Szene in ein digitales, von einem Computer verarbeitbares Format um.</p><p class="mb-2"><strong class="font-semibold">Ortsrasterung (Sampling):</strong></p><ul class="list-disc list-inside mb-4 pl-4 space-y-2"><li><strong>Funktion:</strong> Die kontinuierliche Bildebene wird in ein <strong class="highlight">diskretes Gitter</strong> (Pixel) zerlegt. An jedem Gitterpunkt wird der Helligkeits- oder Farbwert gemessen.</li><li><strong>Zweck:</strong> Überführung der räumlichen Kontinuität in ein diskretes Format. Die <strong class="highlight">Auflösung</strong> bestimmt die Detailgenauigkeit.</li><li><strong>Wichtig:</strong> Gemäß <strong class="highlight">Shannon'schem Abtasttheorem</strong> sollte die Abtastfrequenz mindestens doppelt so hoch sein wie die höchste Frequenz im Signal, um <strong class="highlight">Aliasing</strong> zu vermeiden.</li></ul><p class="mb-2"><strong class="font-semibold">Intensitätsrasterung (Quantisierung):</strong></p><ul class="list-disc list-inside pl-4 space-y-2"><li><strong>Funktion:</strong> Der kontinuierliche Helligkeits-/Farbwert jedes Pixels wird einem von <strong class="highlight">endlich vielen diskreten Werten</strong> zugeordnet.</li><li><strong>Zweck:</strong> Überführung des kontinuierlichen Wertebereichs der Intensität in einen diskreten.</li><li><strong>Beispiel:</strong> Bei 8-Bit werden alle Helligkeiten auf 256 Stufen (0-255) abgebildet.</li></ul></div>`,
            },
            "q2": {
                question: "2. Erkläre die verschiedenen Farbsysteme: CIE, RGB, HSI, YCbCr und CMYK.",
                answer: `<div class="text-left w-full space-y-3"><h3 class="font-bold text-xl mb-3">Farbsysteme</h3><div><strong class="font-semibold">CIE:</strong> Ein <strong class="highlight">geräteunabhängiges Referenzsystem</strong>, das alle für den Menschen sichtbaren Farben umfasst. Dient als Basis für Umrechnungen.</div><div><strong class="font-semibold">RGB (Rot, Grün, Blau):</strong> <strong class="highlight">Additives</strong> Farbmodell für selbstleuchtende Systeme (Monitore, Kameras). Farben werden durch Mischen von Licht erzeugt.</div><div><strong class="font-semibold">HSI (Hue, Saturation, Intensity):</strong> Angelehnt an die menschliche Wahrnehmung.<ul class="list-disc list-inside pl-4"><li><strong>H (Farbton):</strong> Die "Farbe" an sich.</li><li><strong>S (Sättigung):</strong> Die "Buntheit" der Farbe.</li><li><strong>I (Intensität):</strong> Die Helligkeit.</li><li>Vorteil: <strong class="highlight">Entkoppelt Helligkeit von Farbe</strong>.</li></ul></div><div><strong class="font-semibold">YCbCr:</strong> Wichtig für <strong class="highlight">Video- und Bildkompression</strong> (JPEG, MPEG).<ul class="list-disc list-inside pl-4"><li><strong>Y:</strong> Luminanz (Helligkeitsinfo).</li><li><strong>Cb/Cr:</strong> Chrominanz (Farbinformation).</li><li>Nutzt aus, dass das Auge Helligkeit besser wahrnimmt als Farbe, und ermöglicht <strong class="highlight">Farb-Unterabtastung</strong> (z.B. 4:2:0) zur Kompression.</li></ul></div><div><strong class="font-semibold">CMYK (Cyan, Magenta, Yellow, Key/Black):</strong> <strong class="highlight">Subtraktives</strong> Farbmodell für den <strong class="highlight">Druck</strong>. Farben werden von weißem Papier "abgezogen".</div></div>`,
            },
            "q3": {
                question: "3. Was bedeuten 4er- und 8er-Nachbarschaften und was ist der Unterschied?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">4er- und 8er-Nachbarschaften</h3><p class="mb-4">Definieren, welche Pixel als "benachbart" gelten. Fundamental für Filterung, Segmentierung etc.</p><p class="mb-2"><strong class="font-semibold">4-Nachbarschaft (N4):</strong></p><ul class="list-disc list-inside mb-4 pl-4"><li>Umfasst die <strong class="highlight">vier direkten horizontalen und vertikalen</strong> Nachbarn.</li><li>Verbindungen nur entlang der Achsen.</li></ul><p class="mb-2"><strong class="font-semibold">8-Nachbarschaft (N8):</strong></p<ul class="list-disc list-inside pl-4"><li>Umfasst die N4-Pixel <strong class="highlight">PLUS die vier diagonalen</strong> Nachbarn.</li><li>Erlaubt auch diagonale Verbindungen.</li></ul><p class="mt-4"><strong class="font-semibold">Unterschied:</strong> Die Wahl beeinflusst die <strong class="highlight">Konnektivität</strong> von Objekten. Zwei diagonal berührende Pixel sind in N4 getrennt, in N8 aber verbunden.</li></div>`,
            },
            "q4": {
                question: "4. Erkläre die Distanzmaße: Euklidische Distanz, City-Block-Distanz und Schachbrett-Distanz.",
                answer: `<div class="text-left w-full space-y-4"><h3 class="font-bold text-xl mb-3">Distanzmaße</h3><div><strong class="font-semibold">Euklidische Distanz ($D_e$):</strong><ul class="list-disc list-inside pl-4"><li>Die "echte" <strong class="highlight">Luftlinie</strong> zwischen zwei Punkten.</li><li>$$D_e = \\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}$$</li></ul></div><div><strong class="font-semibold">City-Block-Distanz ($D_4$, Manhattan):</strong><ul class="list-disc list-inside pl-4"><li>Bewegung nur entlang der Gitterachsen. Verbunden mit der <strong class="highlight">4-Nachbarschaft</strong>.</li><li>$$D_4 = |x_1-x_2| + |y_1-y_2|$$</li></ul></div><div><strong class="font-semibold">Schachbrett-Distanz ($D_8$):</strong><ul class="list-disc list-inside pl-4"><li>Minimale Züge eines Königs auf dem Schachbrett. Verbunden mit der <strong class="highlight">8-Nachbarschaft</strong>.</li><li>$$D_8 = \\max(|x_1-x_2|, |y_1-y_2|)$$</li></ul></div></div>`,
            },
            "q5": {
                question: "5. Wie ist ein typisches Bildverarbeitungssystem aufgebaut (vom Sensor bis zum Speicher)?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Aufbau eines Bildverarbeitungssystems</h3><p class="mb-4">Wandelt Lichtinformation in digitale Daten um.</p><ol class="list-decimal list-inside space-y-3"><li><strong>Sensor:</strong> Fängt Licht ein und wandelt es in ein <strong class="highlight">analoges elektrisches Signal</strong> um.</li><li><strong>Analog-/Digitaldaten:</strong><ul class="list-disc list-inside ml-6 mt-2"><li><strong class="highlight">Analogkamera:</strong> Gibt kontinuierliches Videosignal aus.</li><li><strong class="highlight">Digitalkamera:</strong> Digitalisiert intern und gibt Digitaldaten aus.</li></ul></li><li><strong>Interface / Framegrabber:</strong><ul class="list-disc list-inside ml-6 mt-2"><li><strong class="highlight">Framegrabber:</strong> Nötig für Analogkameras. "Greift" und digitalisiert einzelne Bilder (Frames) aus dem analogen Signal.</li><li><strong class="highlight">Interface:</strong> Nötig für Digitalkameras zur reinen Datenübertragung (z.B. USB).</li></ul></li><li><strong>Speichermedium / Computer:</strong> Das digitale Bild wird in den <strong class="highlight">Arbeitsspeicher (RAM)</strong> geladen und kann von dort verarbeitet oder gespeichert werden.</li></ol></div>`,
            },
            "q6": {
                question: "6. Was ist ein Framegrabber und welche Funktion hat er?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Framegrabber</h3><p class="mb-3">Ein Framegrabber ist im Kern der <strong class="highlight">Analog-Digital-Wandler</strong> für Videosignale in einem Bildverarbeitungssystem.</p><p class="font-semibold mb-2">Funktion:</p><ol class="list-decimal list-inside space-y-3"><li>Empfängt ein <strong class="highlight">analoges Videosignal</strong> (z.B. PAL) von einer Kamera.</li><li><strong class="highlight">Digitalisiert ("grabbt")</strong> einzelne Bilder (Frames) aus diesem Signal durch:<ul class="list-disc list-inside ml-6 mt-2"><li>Ortsrasterung (Abtasten der Zeilen).</li><li>Intensitätsrasterung (Messen und Umwandeln der Spannung).</li></ul></li><li>Behandelt Besonderheiten wie das <strong class="highlight">Halbbildverfahren (Interlacing)</strong>, indem er zwei Halbbilder zu einem Vollbild zusammensetzt.</li><li>Stellt das fertige digitale Bild dem Computerspeicher zur Verfügung.</li></ol></div>`,
            },
            "q7": {
                question: "7. Wie funktioniert ein Drucker mit dem Halbtonverfahren (Floyd-Steinberg)?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Drucker und Halbtonverfahren</h3><p class="mb-3">Um Graustufen mit nur Schwarz/Weiß zu simulieren, wird das <strong class="highlight">Halbtonverfahren (Dithering)</strong> eingesetzt. Eine intelligente Anordnung von schwarzen und weißen Punkten erzeugt den Eindruck von Grau.</p><p class="font-semibold mb-2">Floyd-Steinberg-Algorithmus:</p><p class="mb-3">Ein Algorithmus zur <strong class="highlight">Fehlerdiffusion</strong>. Der Fehler, der bei der Entscheidung für Schwarz oder Weiß entsteht, wird auf Nachbarpixel verteilt.</p><ol class="list-decimal list-inside space-y-2"><li>Bild wird Pixel für Pixel durchlaufen.</li><li>Pixelwert wird mit einer Schwelle verglichen -> Entscheidung für Schwarz oder Weiß.</li><li>Der <strong class="highlight">Quantisierungsfehler</strong> (Differenz zwischen Originalwert und S/W-Wert) wird berechnet.</li><li>Dieser Fehler wird nach einem festen Schlüssel auf die umliegenden, noch nicht bearbeiteten Pixel verteilt:<ul class="list-disc list-inside ml-6 mt-2"><li><strong class="highlight">7/16</strong> nach rechts</li><li><strong class="highlight">3/16</strong> nach links unten</li><li><strong class="highlight">5/16</strong> nach unten</li><li><strong class="highlight">1/16</strong> nach rechts unten</li></ul></li></ol><p class="mt-4">Dies führt zu einem homogeneren und detailreicheren Ergebnis.</p></div>`,
            },
            "q8": {
                question: "8. Was ist der Unterschied zwischen Ortsraum und Frequenzraum?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Ortsraum vs. Frequenzraum</h3><p class="mb-3">Zwei unterschiedliche Darstellungen eines Bildes.</p><p class="font-semibold mb-2">Ortsraum (Spatial Domain):</p><ul class="list-disc list-inside mb-4 pl-4"><li>Die "normale" Bilddarstellung als <strong class="highlight">Pixelmatrix</strong>.</li><li>Beschreibt, <strong class="highlight">WO</strong> sich Helligkeitsinformationen befinden.</li><li>Operationen (z.B. Faltung) arbeiten direkt mit Pixelnachbarschaften.</li></ul><p class="font-semibold mb-2">Frequenzraum (Frequency Domain):</p><ul class="list-disc list-inside pl-4"><li>Wird durch <strong class="highlight">Fouriertransformation</strong> erreicht.</li><li>Stellt das Bild als Überlagerung von <strong class="highlight">Sinus-/Kosinuswellen</strong> dar.</li><li><strong class="highlight">Niedrige Frequenzen:</strong> Langsame Änderungen (große Flächen).</li><li><strong class="highlight">Hohe Frequenzen:</strong> Schnelle Änderungen (Kanten, Details).</li><li>Beschreibt, <strong class="highlight">WIE OFT</strong> sich Helligkeitsinformationen ändern.</li></ul></div>`,
            },
            "q9": {
                question: "9. Was sind Aliasing-Artefakte und wie entstehen sie?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Aliasing-Artefakte</h3><p class="mb-3"><strong class="font-semibold">Definition:</strong> Störungen (z.B. Moiré-Muster, Treppeneffekte), die entstehen, wenn ein Bild mit <strong class="highlight">zu geringer Frequenz/Auflösung</strong> abgetastet wird.</p><p class="font-semibold mb-2">Ursache: Verletzung des Shannon'schen Abtasttheorems</p><ul class="list-disc list-inside mb-4 pl-4"><li><strong class="highlight">Theorem:</strong> Abtastfrequenz muss <strong class="highlight">größer als das Doppelte</strong> der maximalen Signalfrequenz sein ($f_{\\text{abtast}} > 2 \\cdot f_{\\text{max}}$).</li><li><strong>Bedeutung für Bilder:</strong> Die Sensorauflösung muss hoch genug sein, um die feinsten Details der Szene korrekt zu erfassen (mindestens 2 Pixel pro Musterperiode).</li></ul><p class="font-semibold mb-2">Entstehung:</p><p>Wenn das Theorem verletzt wird, können hohe Frequenzen (feine Details) nicht korrekt erfasst werden und werden fälschlicherweise als <strong class="highlight">niedrigere Frequenzen interpretiert</strong>, die im Original nicht vorhanden waren. Dadurch entstehen neue, künstliche Muster.</p></div>`,
            },
            "q10": {
                question: "10. Wie funktioniert die deterministische Faltung mit einem Filterkern?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Deterministische Faltung</h3><p class="mb-3">Die Faltung ist die Grundoperation der <strong class="highlight">linearen Filterung</strong>. Ein Filterkern (Maske) wird über das Bild bewegt, um ein neues Bild zu erzeugen.</p><p class="font-semibold mb-2">Schritte:</p><ol class="list-decimal list-inside space-y-2 pl-4"><li><strong>Filterkern definieren:</strong> Eine kleine Matrix (z.B. 3x3), die den Filtereffekt bestimmt.</li><li><strong class="highlight">Kern um 180° drehen:</strong> Für die Faltungs-Definition wird der Kern gespiegelt.</li><li><strong>Anwenden:</strong> Der gedrehte Kern wird über jedes Pixel des Originalbildes gelegt.</li><li><strong>Berechnen:</strong> Der neue Pixelwert ist die <strong class="highlight">Summe der elementweisen Produkte</strong> von Kernwerten und den darunterliegenden Bildpixeln.</li></ol><p class="mt-4">Formel der 2D-Faltung:</p>$$g'(m, n) = \\sum_{m'=-r}^{r} \\sum_{n'=-r}^{r} h(m', n') \\cdot g(m - m', n - n')$$</div>`,
            },
            "q11": {
                question: "11. Was sind stochastische Einflüsse wie Rauschen?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Stochastische Einflüsse (Rauschen)</h3><p class="mb-3">Zufällige, nicht vorhersagbare Störungen, die die Pixelwerte verfälschen. Sie können statistisch beschrieben werden. Modell: $g(m,n) = f(m,n) + \\eta(m,n)$ (additives Rauschen).</p><p class="mb-3"><strong class="font-semibold">Gauß'sches Rauschen:</strong></p><ul class="list-disc list-inside pl-4"><li><strong>Beschreibung:</strong> Rauschwerte folgen einer <strong class="highlight">Normalverteilung</strong>. Beeinflusst alle Pixel.</li><li><strong>Ursachen:</strong> <strong class="highlight">Thermisches Rauschen</strong> im Sensor, Elektronikrauschen. Verstärkt bei hohen ISO-Werten.</li></ul><p class="mb-3"><strong class="font-semibold">Impulsrauschen ("Salt & Pepper"):</strong></p><ul class="list-disc list-inside pl-4"><li><strong>Beschreibung:</strong> Einzelne Pixel werden auf <strong class="highlight">minimalen oder maximalen Wert</strong> gesetzt.</li><li><strong>Ursachen:</strong> Übertragungsfehler, defekte Sensorpixel.</li></ul><p class="mb-3"><strong class="font-semibold">Periodisches Rauschen:</strong></p><ul class="list-disc list-inside pl-4"><li><strong>Beschreibung:</strong> Regelmäßige, wellenartige Störung. Zeigt sich als <strong class="highlight">Spikes im Frequenzraum</strong>.</li><li><strong>Ursachen:</strong> Elektrische Störungen (z.B. Netzbrummen).</li></ul></div>`,
            },
            "q12": {
                question: "12. Was sagen Mittelwert und Varianz über ein Bild aus?",
                answer: `<div class="text-left w-full space-y-4"><h3 class="font-bold text-xl mb-3">Mittelwert & Varianz</h3><div><strong class="font-semibold">Mittelwert ($\overline{z}$):</strong><ul class="list-disc list-inside pl-4"><li><strong>Aussage:</strong> Maß für die <strong class="highlight">durchschnittliche Helligkeit</strong>.</li><li>$$\\overline{z} = \\frac{1}{N} \\sum_{j=0}^{y} \\sum_{k=0}^{x} s(j, k)$$</li></ul></div><div><strong class="font-semibold">Varianz ($\sigma^2$):</strong><ul class="list-disc list-inside pl-4"><li><strong>Aussage:</strong> Maß für den <strong class="highlight">Kontrast</strong>.</li><li>Hohe Varianz = kontrastreich, niedrige Varianz = kontrastarm.</li><li>$$\\sigma^2 = \\frac{1}{N-1} \\sum_{j=y_a}^{y_c} \\sum_{k=x_a}^{x_c} (f_{jk} - \\overline{z})^2$$</li></ul></div></div>`,
            },
            "q13": {
                question: "13. Wie funktionieren Histogramme?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Histogramme</h3><p class="mb-3"><strong class="font-semibold">Definition:</strong> Ein Histogramm zeigt, <strong class="highlight">wie häufig jeder Grauwert</strong> ($g$) in einem Bild vorkommt.</p><p class="font-semibold mb-2">Interpretation der Verteilung:</p><ul class="list-disc list-inside pl-4 space-y-2"><li><strong>Helligkeit:</strong><ul class="list-disc list-inside ml-4"><li>Balken links konzentriert = <strong class="highlight">dunkles Bild</strong>.</li><li>Balken rechts konzentriert = <strong class="highlight">helles Bild</strong>.</li></ul></li><li><strong>Kontrast:</strong><ul class="list-disc list-inside ml-4"><li>Balken auf engem Bereich = <strong class="highlight">kontrastarm</strong>.</li><li>Balken über breiten Bereich verteilt = <strong class="highlight">kontrastreich</strong>.</li></ul></li></ul><p class="mt-4">Wichtig: Ein Histogramm enthält <strong class="highlight">keine räumliche Information</strong>.</p></div>`,
            },
            "q14": {
                question: "14. Wie wird die Entropie eines Bildes berechnet und wofür ist sie gut?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Entropie</h3><p class="mb-3">Ein Maß für den <strong class="highlight">Informationsgehalt</strong> eines Bildes.</p><p class="font-semibold mb-2">Nutzen:</p><ul class="list-disc list-inside mb-4 pl-4"><li>Gibt die <strong class="highlight">durchschnittliche Informationsmenge pro Pixel</strong> an.</li><li>Definiert eine theoretische <strong class="highlight">untere Schranke für die verlustfreie Kompression</strong>.</li></ul><p class="font-semibold mb-2">Berechnung:</p><ul class="list-disc list-inside pl-4"><li>Basiert auf den relativen Häufigkeiten $p_r(k)$ der Grauwerte $k$.</li><li>$$H = - \\sum_{k=0}^{g} p_r(k) \\cdot \\log_2(p_r(k))$$</li><li>$H=0$ für einfarbiges Bild, $H=\\text{max}$ (z.B. 8) bei Gleichverteilung.</li></ul></div>`,
            },
            "q15": {
                question: "15. Was ist eine Grauwertmatrix (Co-occurrence Matrix) und wie wird sie berechnet? Analysieren Sie das gegebene Bild.",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Grauwertmatrix (Co-occurrence Matrix)</h3><p class="mb-3">Beschreibt die <strong class="highlight">Textur</strong> eines Bildes durch Analyse der <strong class="highlight">räumlichen Beziehung</strong> zwischen Grauwerten.</p><p class="font-semibold mb-2">Berechnung:</p><ol class="list-decimal list-inside pl-4 space-y-2"><li>Definiere eine räumliche Relation $p = (\\Delta x, \\Delta y)$ (z.B. "rechter Nachbar").</li><li>Initialisiere eine Matrix, deren Größe den Grauwerten entspricht (z.B. 256x256).</li><li>Durchlaufe das Bild: Zähle für jedes Pixel, wie oft ein Pixel mit Grauwert $i$ in der definierten Relation zu einem Pixel mit Grauwert $j$ steht.</li><li>Trage diese Häufigkeit in die Matrix am Index $(i, j)$ ein.</li></ol><p class="font-semibold mt-4 mb-2">Analyse des Beispielbilds (Relation: "rechter Nachbar"):</p><div class="flex flex-col md:flex-row gap-4 items-center"><div class="flex-shrink-0">Gegebenes Bild:<br><pre class="bg-gray-100 dark:bg-gray-800 p-2 rounded">4 4 3 3<br>4 4 3 3<br>4 4 4 3<br>4 4 4 4</pre></div><div class="flex-grow">Ergebnis-Matrix:<br><table class="table-auto border-collapse border border-slate-500"><thead><tr><th class="border border-slate-600 p-2"></th><th class="border border-slate-600 p-2">3</th><th class="border border-slate-600 p-2">4</th></tr></thead><tbody><tr><td class="border border-slate-700 p-2 font-bold">3</td><td class="border border-slate-700 p-2 text-center">3</td><td class="border border-slate-700 p-2 text-center">0</td></tr><tr><td class="border border-slate-700 p-2 font-bold">4</td><td class="border border-slate-700 p-2 text-center">3</td><td class="border border-slate-700 p-2 text-center">9</td></tr></tbody></table></div></div><p class="font-semibold mt-4 mb-2">Bewertung:</p><ul class="list-disc list-inside pl-4"><li>Die Werte sind stark auf der <strong class="highlight">Hauptdiagonalen</strong> konzentriert (Paare 3-3 und 4-4).</li><li>Dies deutet auf ein <strong class="highlight">homogenes, flächiges Bild</strong> mit wenig Kontrast und feiner Textur hin, was dem visuellen Eindruck entspricht.</li></ul></div>`
            },
            "q16": {
                question: "16. Fouriertransformation: Zweck, Amplitude & Phase",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Fouriertransformation</h3><p class="mb-3"><strong class="font-semibold">Zweck:</strong> Überführt ein Bild vom <strong class="highlight">Ortsraum in den Frequenzraum</strong>. Zerlegt das Bild in überlagerte Sinus-/Kosinuswellen.</p><p class="mb-3"><strong class="font-semibold">Amplitudenspektrum ($A = |F(u,v)|$):</strong></p><ul class="list-disc list-inside pl-4"><li>Gibt an, <strong class="highlight">wie stark jede Frequenz</strong> im Bild vertreten ist. Visuell aussagekräftiger.</li><li>Eine <strong class="highlight">Rotation</strong> im Ortsraum bewirkt eine Rotation im Amplitudenbild.</li></ul><p class="mb-3"><strong class="font-semibold">Phasenspektrum ($\\theta$):</strong><ul class="list-disc list-inside pl-4"><li>Gibt die <strong class="highlight">Position/Verschiebung</strong> der Frequenzwellen an.</li><li>$$\\theta = \\arctan\\left(\\frac{\\text{Im}(F(u,v))}{\\text{Re}(F(u,v))}\\right)$$</li><li>Enthält die entscheidende Information über die <strong class="highlight">Position der Bildstrukturen</strong>.</li><li>Eine <strong class="highlight">Translation</strong> im Ortsraum wirkt sich nur auf das Phasenbild aus.</li></ul></div>`,
            },
            "q17": {
                question: "17. Was macht ein Tiefpassfilter?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Tiefpassfilter</h3><p class="mb-3"><strong class="font-semibold">Funktion:</strong> Lässt niedrige Frequenzen passieren und <strong class="highlight">entfernt hohe Frequenzen</strong>.</p><p class="font-semibold mb-2">Effekte:</p><ul class="list-disc list-inside mb-4 pl-4"><li><strong class="highlight">Glättung / Weichzeichnung:</strong> Kanten werden weicher, das Bild verschwommener.</li><li><strong class="highlight">Rauschunterdrückung:</strong> Entfernt hochfrequentes Rauschen.</li></ul><p class="font-semibold mb-2">Anwendungen:</p><ul class="list-disc list-inside pl-4"><li>Vorverarbeitung zur Rauschentfernung.</li><li>Erzeugung von Unschärfe-Effekten.</li><li><strong class="highlight">Anti-Aliasing</strong> beim Verkleinern von Bildern.</li></ul></div>`,
            },
            "q18": {
                question: "18. Erkläre die Arten von Tiefpassfiltern.",
                answer: `<div class="text-left w-full space-y-4"><h3 class="font-bold text-xl mb-3">Arten von Tiefpassfiltern</h3><p>Unterscheiden sich im Übergang vom Durchlass- zum Sperrbereich im Frequenzraum.</p><div><strong class="font-semibold">1. Idealer Tiefpass:</strong><ul class="list-disc list-inside pl-4"><li><strong class="highlight">Extrem harter Übergang</strong>. $H(u,v)$ ist 1, wenn $D(u,v) \\le D_0$, sonst 0.</li><li>Nachteil: Verursacht starke <strong class="highlight">Ringing-Artefakte</strong>.</li></ul></div><div><strong class="font-semibold">2. Butterworth-Tiefpass:</strong><ul class="list-disc list-inside pl-4"><li><strong class="highlight">Glatterer, kurvenförmiger Übergang</strong>.</li><li>$$H(u,v) = \\frac{1}{1 + [D(u,v)/D_0]^{2n}}$$</li><li>Deutlich weniger Ringing-Artefakte. Die Ordnung $n$ steuert die Steilheit.</li></ul></div><div><strong class="font-semibold">3. Gauß'scher Tiefpass:</strong><ul class="list-disc list-inside pl-4"><li><strong class="highlight">Sehr weicher Übergang</strong> (Glockenkurve).</li><li>$$H(u,v) = e^{-\\frac{D^2(u,v)}{2D_0^2}}$$</li><li>Vorteil: Erzeugt <strong class="highlight">keine Ringing-Artefakte</strong>.</li></ul></div></div>`,
            },
            "q19": {
                question: "19. Was macht ein Hochpassfilter?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Hochpassfilter</h3><p class="mb-3"><strong class="font-semibold">Funktion:</strong> Lässt hohe Frequenzen passieren und <strong class="highlight">entfernt niedrige Frequenzen</strong>. Kann erstellt werden über $H_{HP} = 1 - H_{LP}$.</p><p class="font-semibold mb-2">Effekte:</p><ul class="list-disc list-inside mb-4 pl-4"><li><strong class="highlight">Kantenanhebung / Schärfung:</strong> Details werden hervorgehoben.</li><li><strong class="highlight">Rauschverstärkung:</strong> Verstärkt vorhandenes Rauschen.</li></ul><p class="font-semibold mb-2">Anwendungen:</p><ul class="list-disc list-inside pl-4"><li>Bildschärfung.</li><li><strong class="highlight">Kantendetektion</strong> (z.B. mit Sobel-, Laplace-Filter).</li><li>Hervorhebung feiner Strukturen (Medizin, Materialprüfung).</li></ul></div>`,
            },
            "q20": {
                question: "20. Erkläre den Laplace-Filter.",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Laplace-Filter</h3><p class="mb-3">Ein Hochpassfilter, der auf der <strong class="highlight">zweiten Ableitung</strong> basiert.</p><p class="font-semibold mb-2">Anwendung im Ortsraum:</p><ul class="list-disc list-inside pl-4 space-y-2"><li>Typische Faltungskerne:</li><li class="flex justify-around items-center space-x-4">$$\\begin{pmatrix} 0 & 1 & 0 \\\\ 1 & -4 & 1 \\\\ 0 & 1 & 0 \\end{pmatrix} \\quad \\text{und} \\quad \\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & -8 & 1 \\\\ 1 & 1 & 1 \\end{pmatrix}$$</li><li><strong class="font-semibold">Anwendung zur Schärfung:</strong> Das Ergebnis des Filters wird vom Originalbild subtrahiert:</li><li>$$g_{\\text{geschärft}}(x,y) = f_{\\text{original}}(x,y) - \\nabla^2 f(x,y)$$</li><li><strong class="highlight">Nachteil:</strong> Verstärkt Rauschen stark.</li></ul></div>`,
            },
            "q21": {
                question: "21. Was machen Bandpass- und Notch-Filter?",
                answer: `<div class="text-left w-full space-y-4"><h3 class="font-bold text-xl mb-3">Spezialfilter</h3><div><strong class="font-semibold">Bandpassfilter:</strong><ul class="list-disc list-inside pl-4"><li>Lässt nur einen <strong class="highlight">bestimmten Frequenzbereich ("Band")</strong> passieren.</li><li>Anwendung: <strong class="highlight">Isolierung von Strukturen</strong> einer bestimmten Größe (z.B. Texturen).</li></ul></div><div><strong class="font-semibold">Notch-Filter (Bandsperre):</strong><ul class="list-disc list-inside pl-4"><li><strong class="highlight">Unterdrückt einen sehr spezifischen, schmalen Frequenzbereich</strong>.</li><li>Hauptanwendung: <strong class="highlight">Entfernung von periodischem Rauschen</strong>, das als helle Spikes im Frequenzraum sichtbar ist.</li></ul></div></div>`,
            },
            "q22": {
                question: "22. Was ist der Unterschied zwischen Transformation und Ortsfilterung?",
                answer: `<div class="text-left w-full space-y-4"><h3 class="font-bold text-xl mb-3">Transformation vs. Ortsfilterung</h3><p>Der Unterschied liegt in der <strong class="highlight">Größe des Operators</strong>.</p><div><strong class="font-semibold">Intensitätstransformation (Punktoperation):</strong><ul class="list-disc list-inside pl-4"><li>Operatorgröße: <strong class="highlight">1x1</strong>.</li><li>Neuer Wert $s$ hängt <strong class="highlight">nur vom eigenen, alten Wert</strong> $r$ ab: $s=T(r)$.</li><li>Zweck: Globale Helligkeits-/Kontrastanpassung (z.B. Gammakorrektur: $s = cr^\\gamma$).</li></ul></div><div><strong class="font-semibold">Ortsfilterung (Nachbarschaftsoperation):</strong><ul class="list-disc list-inside pl-4"><li>Operatorgröße: <strong class="highlight">Größer als 1x1</strong> (z.B. 3x3-Maske).</li><li>Neuer Wert wird aus einer <strong class="highlight">lokalen Nachbarschaft</strong> berechnet.</li><li>Zweck: Rauschunterdrückung, Schärfung, Kantendetektion (z.B. Mittelwertfilter).</li></ul></div></div>`,
            },
            "q23": {
                question: "23. Was sind lineare Filter?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Lineare Filter</h3><ul class="list-disc list-inside pl-4 space-y-2"><li>Ihre mathematische Grundlage ist die <strong class="highlight">Faltung</strong>.</li><li>Der neue Pixelwert ist eine <strong class="highlight">gewichtete Summe</strong> seiner Nachbarn, definiert durch den Faltungskern.</li><li>Sie erfüllen das <strong class="highlight">Superpositionsprinzip</strong> (Linearität).</li><li><strong class="font-semibold">Hauptzweck:</strong> Unterdrückung von stochastischem Rauschen (z.B. Gauß) und Frequenzfilterung (Tiefpass/Hochpass).</li><li><strong>Beispiele:</strong> Mittelwertfilter, Binomialfilter, Gauß-Filter, Sobel-Filter.</li></ul></div>`,
            },
            "q24": {
                question: "24. Mittelwertfilter vs. Binomialfilter: Unterschiede?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Mittelwertfilter vs. Binomialfilter</h3><p class="mb-3">Beide sind lineare <strong class="highlight">Tiefpassfilter</strong> zur Glättung.</p><p class="mb-3"><strong class="font-semibold">Mittelwertfilter:</strong></p><ul class="list-disc list-inside pl-4"><li>Bildet den <strong class="highlight">einfachen Durchschnitt</strong>. Alle Nachbarn werden <strong class="highlight">gleich gewichtet</strong>.</li><li>$$h = \\frac{1}{9} \\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{pmatrix}$$</li></ul><p class="mb-3"><strong class="font-semibold">Binomialfilter:</strong></p><ul class="list-disc list-inside pl-4"><li><strong class="highlight">Gewichteter Durchschnitt</strong>: Pixel näher am Zentrum erhalten höheres Gewicht.</li><li>$$h = \\frac{1}{16} \\begin{pmatrix} 1 & 2 & 1 \\\\ 2 & 4 & 2 \\\\ 1 & 2 & 1 \\end{pmatrix}$$</li><li>Gilt als <strong class="highlight">besserer Tiefpassfilter</strong>, da er Kanten besser erhält.</li></ul></div>`,
            },
            "q25": {
                question: "25. Was sind nicht-lineare Filter?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Nicht-lineare Filter</h3><ul class="list-disc list-inside pl-4 space-y-2"><li>Erfüllen <strong class="highlight">nicht</strong> das Superpositionsprinzip, basieren nicht auf Faltung.</li><li>Sind <strong class="highlight">nur im Ortsraum definiert</strong>.</li><li>Oft effektiver bei bestimmten Rauscharten (z.B. Impulsrauschen).</li><li><strong class="font-semibold">Wichtigster Vertreter:</strong> Der <strong class="highlight">Medianfilter</strong>.</li><li><strong>Weitere Beispiele:</strong> Rangordnungsfilter, Morphologische Operationen.</li></ul></div>`,
            },
            "q26": {
                question: "26. Wie funktioniert der Medianfilter?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Medianfilter</h3><p class="mb-3">Ein <strong class="highlight">nicht-linearer Rangordnungsfilter</strong>, exzellent zur Entfernung von <strong class="highlight">Impulsrauschen (Salt & Pepper)</strong>.</p><p class="font-semibold mb-2">Funktionsweise:</p><ol class="list-decimal list-inside pl-4 space-y-2"><li>Eine Maske (z.B. 3x3) wird über das Bild geschoben.</li><li>Alle Pixelwerte in der Maske werden gesammelt.</li><li>Diese Werte werden <strong class="highlight">der Größe nach sortiert</strong>.</li><li>Der <strong class="highlight">Median</strong> (der mittlere Wert der sortierten Liste) wird ausgewählt.</li><li>Das zentrale Pixel wird durch diesen Median ersetzt.</li></ol><p class="font-semibold mt-4 mb-2">Vorteile:</p><ul class="list-disc list-inside pl-4"><li><strong class="highlight">Robust gegen Ausreißer:</strong> Extreme Werte (0 oder 255) beeinflussen den Median nicht.</li><li><strong class="highlight">Kantenerhaltend:</strong> Es werden keine neuen Grauwerte erzeugt.</li></ul></div>`,
            },
            "q27": {
                question: "27. Erkläre die Interpolationsverfahren.",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Interpolationsverfahren</h3><p class="mb-3">Nötig bei geometrischen Transformationen (Skalieren, Drehen), um neue Pixelwerte zu berechnen.</p><p class="mb-3"><strong class="font-semibold">Nearest Neighbor:</strong></p><ul class="list-disc list-inside pl-4"><li><strong class="highlight">Funktion:</strong> Ordnet den Wert des nächstgelegenen Originalpixels zu.</li><li><strong class="highlight">Ergebnis:</strong> Sehr schnell, aber blockartig/"pixelig" beim Vergrößern.</li></ul><p class="mb-3"><strong class="font-semibold">Bi-Lineare Interpolation:</strong></p><ul class="list-disc list-inside pl-4"><li><strong class="highlight">Funktion:</strong> Gewichteter Durchschnitt der <strong class="highlight">vier</strong> nächsten Nachbarn.</li><li><strong class="highlight">Ergebnis:</strong> Weichere Übergänge, weniger blockartig.</li></ul><p class="mb-3"><strong class="font-semibold">Bi-Kubische Interpolation:</strong></p<ul class="list-disc list-inside pl-4"><li><strong class="highlight">Funktion:</strong> Nutzt die <strong class="highlight">16 (4x4)</strong> nächsten Nachbarn und eine kubische Funktion.</li><li>$$g(x,y)=\\sum_{i=0}^{3}\\sum_{j=0}^{3}a_{ij}x^{i}y^{j}$$</li><li><strong class="highlight">Ergebnis:</strong> Qualitativ am hochwertigsten, schärfer und detailreicher.</li></ul></div>`,
            },
            "q28": {
                question: "28. Wie funktioniert Segmentierung?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Segmentierung</h3><p class="mb-3"><strong class="font-semibold">Zweck:</strong> Ein Bild in mehrere <strong class="highlight">sinnvolle, zusammenhängende Regionen</strong> (Segmente) unterteilen, um Objekte zu isolieren.</p><p class="font-semibold mb-2">Methoden:</p><ul class="list-disc list-inside pl-4 space-y-2"><li><strong>Histogrammbasiert (Schwellenwert):</strong><ul class="list-disc list-inside ml-4"><li>Funktioniert bei klaren Helligkeitsunterschieden.</li><li>Ein <strong class="highlight">Schwellenwert</strong> trennt das Bild in Vorder- und Hintergrund, was zu einem Binärbild führt.</li></ul></li><li><strong>Kantenbasiert:</strong> Sucht nach Grenzen zwischen Regionen mittels Kantendetektoren (z.B. Sobel, Canny).</li><li><strong>Regionenbasiert (z.B. Quadtree):</strong> Teilt das Bild rekursiv in Quadranten, bis diese homogen sind.</li></ul></div>`,
            },
            "q29": {
                question: "29. Was sind morphologische Operationen?",
                answer: "<div =\"text-left w-full\"><h3 class=\"font-bold text-xl mb-3\">Morphologische Operationen</h3><p class=\"mb-3\">Nicht-lineare Filter (mathematische Morphologie), die die <strong class=\"highlight\">Form und Struktur</strong> von Bildobjekten beeinflussen. Sie basieren auf einem <strong class=\"highlight\">Strukturierenden Element</strong> (einer binären Maske mit Bezugspunkt), das über das Bild bewegt wird.</p><p class=\"font-semibold mb-2\">Grundoperationen:</p><ul class=\"list-disc list-inside mb-4 pl-4\"><li><strong class=\"highlight\">Dilation (Erweiterung):</strong> Macht helle Bildstrukturen größer und schließt kleine Lücken.</li><li><strong class=\"highlight\">Erosion (Verdünnung):</strong> Macht helle Bildstrukturen kleiner und eliminiert feine Störungen.</li></ul><p class=\"font-semibold mb-2\">Komplexe Operationen:</p><ul class=\"list-disc list-inside mb-4 pl-4\"><li><strong>Opening (Öffnung):</strong> Erosion, gefolgt von Dilation. <strong class=\"highlight\">Entfernt kleine helle Objekte</strong>.</li><li><strong>Closing (Schließung):</strong> Dilation, gefolgt von Erosion. <strong class=\"highlight\">Schließt kleine dunkle Lücken</strong> in hellen Strukturen.</li><li><strong>Tophat:</strong> Das Ergebnis der Subtraktion des geöffneten Bildes vom Originalbild ($Originalbild - Opening(Bild)$). <strong class=\"highlight\">Hebt kleine, helle Details hervor</strong> (Anwendung z.B. in der Qualitätskontrolle).</li></ul><p class=\"font-semibold mb-2\">Anwendung auf Grauwertbilder:</p><p class=\"pl-4\">Bei Grauwertbildern werden die logischen Operatoren durch <strong class=\"highlight\">min</strong> für die Erosion und <strong class=\"highlight\">max</strong> für die Dilation ersetzt, angewendet auf die Helligkeitswerte der Pixel.</p></div>",
            },
            "q30": {
                question: "30. Sobel vs. Canny: Vorteile von Canny?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Kantenextraktion: Sobel vs. Canny</h3><p class="mb-3"><strong class="font-semibold">Sobel:</strong> Einfacher Kantenfilter (1. Ableitung), anfällig für Rauschen, erzeugt dicke Kanten.</p><p class="mb-3"><strong class="font-semibold">Canny:</strong> Ein mehrstufiger, überlegener Algorithmus. Die Vorteile liegen in den zusätzlichen Schritten:</p><ol class="list-decimal list-inside pl-4 space-y-2"><li><strong class="highlight">Gauß-Filterung:</strong> Reduziert Rauschen vor der Kantendetektion.</li><li><strong class="highlight">Non-Maxima-Suppression:</strong> Dünnt die Kanten auf eine Breite von einem Pixel aus.</li><li><strong class="highlight">Hysterese-Schwellenwertbildung:</strong> Verwendet zwei Schwellenwerte, um Kantenverläufe besser zu verfolgen und Störkanten zu reduzieren.</li></ol></div>`,
            },
            "q31": {
             question: "31. Unterscheide die Kompressionsarten.",
                answer: `<div class="text-left w-full space-y-3"><h3 class="font-bold text-xl mb-3">Arten der Redundanzreduktion</h3><div><strong class="font-semibold">1. Signalkompression (Statistische Red.):</strong><ul class="list-disc list-inside pl-4"><li>Nutzt aus, dass Grauwerte unterschiedlich häufig vorkommen.</li><li>Methode: <strong class="highlight">Entropiecodierung (z.B. Huffman)</strong>. Typ: <strong class="highlight">Verlustfrei</strong>.</li></ul></div><div><strong class="font-semibold">2. Räumliche Redundanzreduktion:</strong><ul class="list-disc list-inside pl-4"><li>Nutzt aus, dass benachbarte Pixel oft ähnlich sind.</li><li>Methoden: <strong class="highlight">Lauflängencodierung (RLE)</strong>, Transformationen (DCT).</li></ul></div><div><strong class="font-semibold">3. Wahrnehmungsredundanzreduktion (Psychovisuelle Red.):</strong><ul class="list-disc list-inside pl-4"><li>Nutzt die Grenzen der menschlichen Wahrnehmung aus.</li><li>Methoden: <strong class="highlight">Quantisierung</strong> (Hauptquelle für Verluste), <strong class="highlight">Farb-Unterabtastung</strong>.</li><li>Typ: Immer <strong class="highlight">verlustbehaftet</strong>.</li></ul></div></div>`,
            },
            "q32": {
               question: "32. Erkläre die Huffman-Codierung.",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Huffman-Codierung</h3><p class="mb-3">Ein Algorithmus zur verlustfreien <strong class="highlight">Entropiecodierung</strong>.</p><ol class="list-decimal list-inside space-y-2 pl-4"><li><strong>Häufigkeiten bestimmen:</strong> Relative Häufigkeit jedes Grauwertes im Bild ermitteln.</li><li><strong>Baum aufbauen:</strong><ul class="list-disc list-inside ml-4"><li>Beginne mit jedem Grauwert als einzelner Knoten.</li><li>Wiederholt: Fasse die <strong class="highlight">zwei Knoten mit der geringsten Häufigkeit</strong> zu einem neuen Elternknoten zusammen.</li><li>Fahre fort, bis nur noch ein Wurzelknoten übrig ist.</li></ul></li><li><strong>Codebuch erstellen:</strong> Weise jedem linken Ast eine '0' und jedem rechten eine '1' zu. Der Code eines Grauwertes ist der Pfad von der Wurzel zum Blatt.</li><li><strong class="highlight">Ergebnis:</strong> Häufige Werte haben kurze Codes, seltene Werte lange Codes.</li></ol></div>`,
            },
            "q33": {
               question: "33. Erkläre den JPEG-Algorithmus.",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">JPEG-Algorithmus</h3><p class="mb-3">Standard zur verlustbehafteten Einzelbildkompression.</p><ol class="list-decimal list-inside space-y-3 pl-4"><li><strong>Farbraumtransformation:</strong> RGB -> <strong class="highlight">YCbCr</strong>. Trennt Helligkeit (Y) von Farbe (CbCr).</li><li><strong>Transformation (DCT):</strong><ul class="list-disc list-inside ml-4"><li>Bild wird in <strong class="highlight">8x8 Blöcke</strong> zerlegt.</li><li>Auf jeden Block wird die <strong class="highlight">Diskrete Kosinustransformation (DCT)</strong> angewendet.</li><li>Ergebnis: 1 <strong class="highlight">DC-Koeffizient</strong> (Durchschnittshelligkeit) und 63 <strong class="highlight">AC-Koeffizienten</strong> (Details).</li></ul></li><li><strong>Quantisierung:</strong><ul class="list-disc list-inside ml-4"><li><strong class="highlight">Der entscheidende verlustbehaftete Schritt.</strong></li><li>Jeder DCT-Koeffizient wird durch einen Wert aus einer Quantisierungstabelle geteilt und gerundet.</li><li>Hohe Frequenzen werden gröber quantisiert. Viele Koeffizienten werden 0.</li></ul></li><li><strong>Codierung:</strong><ul class="list-disc list-inside ml-4"><li>Die Koeffizienten werden im <strong class="highlight">Zig-Zag-Muster</strong> ausgelesen.</li><li>Kompression mit <strong class="highlight">Lauflängencodierung (RLE)</strong> und <strong class="highlight">Huffman-Codierung</strong>.</li></ul></li></ol></div>`,
            },
            "q34": {
                question: "34. Wie funktioniert Videokompression (z.B. MPEG)?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Videokompression (z.B. MPEG)</h3><p class="mb-3">Nutzt zusätzlich zur räumlichen auch die <strong class="highlight">zeitliche Redundanz</strong> (Ähnlichkeit zwischen Bildern).</p><p class="font-semibold mb-2">Bildtypen (Frames):</p><ul class="list-disc list-inside mb-4 pl-4"><li><strong class="highlight">I-Frame (Intra):</strong> Referenzbild. Wie ein JPEG komprimiert.</li><li><strong class="highlight">P-Frame (Predicted):</strong> Speichert nur die Änderungen zu einem <strong class="highlight">vorherigen</strong> Frame.</li><li><strong class="highlight">B-Frame (Bi-directional):</strong> Nutzt ein <strong class="highlight">vorheriges und ein zukünftiges</strong> Bild für die Vorhersage. Effizienteste Kompression.</li></ul><p class="font-semibold mb-2">Hauptschritte:</p><ol class="list-decimal list-inside pl-4 space-y-2"><li><strong>Bewegungsschätzung:</strong> Für einen Block wird im Referenzbild der passendste Block gesucht. Die Verschiebung ist der <strong class="highlight">Bewegungsvektor</strong>.</li><li><strong>Bewegungskompensation:</strong> Aus den Vektoren und dem Referenzbild wird ein Vorhersagebild erstellt.</li><li><strong>Codierung:</strong> Nur die <strong class="highlight">Differenz</strong> zwischen Original und Vorhersage sowie die Vektoren werden gespeichert.</li></ol></div>`,
            },
            "q35": {
                question: "35. Warum ist ein Binomialfilter einem Mittelwertfilter als Tiefpassfilter vorzuziehen?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Binomialfilter vs. Mittelwertfilter</h3><p class="mb-3">Ein Binomialfilter ist vorzuziehen, da er <strong class="highlight">hohe Frequenzen deutlich besser dämpft</strong> und gleichzeitig <strong class="highlight">Kanteninformationen besser erhält</strong>. Dies führt zu einem schärferen, qualitativ hochwertigeren Ergebnis.</p><p class="font-semibold mb-2">Betrachtung im Frequenzraum:</p><ul class="list-disc list-inside mb-4 pl-4"><li><strong>Mittelwertfilter:</strong> Sein Frequenzgang ähnelt einer <strong class="highlight">sinc-Funktion</strong> ($sinc(x) = sin(x)/x$). Diese hat neben dem Hauptmaximum (dem Tiefpass) auch <strong class="highlight">signifikante Nebenmaxima (Sidelobes)</strong>. Diese lassen unerwünschte hohe Frequenzen passieren, was zu Artefakten führt.</li><li><strong>Binomialfilter:</strong> Sein Frequenzgang ist eine <strong class="highlight">Gauß-ähnliche Kurve</strong>. Diese fällt zu hohen Frequenzen hin monoton ab und hat <strong class="highlight">keine Nebenmaxima</strong>. Dadurch werden hohe Frequenzen sauber und vollständig unterdrückt.</li></ul><div class="freq-sketch dark:bg-gray-800 p-4 rounded-lg mt-4"><p class="font-semibold text-center">Skizze der Amplitudenübertragungsfunktionen |H(f)|:</p><div class="text-xs text-center mt-2">Frequenz (f) &rarr;</div><div class="w-full bg-gray-200 dark:bg-gray-700 h-px relative mt-1"><div class="absolute -left-1 -top-2 text-xs">0</div></div><p class="mt-2"><strong class="text-blue-600 dark:text-blue-400">Blau (Binomial):</strong> Glockenförmiger, monotoner Abfall. Beste Dämpfung.</p><p class="mt-1"><strong class="text-red-600 dark:text-red-400">Rot (Mittelwert):</strong> sinc-Form mit unerwünschten "Ausschlägen" (Sidelobes) bei höheren Frequenzen.</p></div></div>`
            },
            "q36": {
                question: "36. Charakterisieren Sie Impulsrauschen. Wie kann man es am besten entfernen?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Impulsrauschen (Salt-and-Pepper Noise)</h3><p class="mb-3"><strong class="font-semibold">Charakteristik:</strong></p><ul class="list-disc list-inside mb-4 pl-4"><li>Auch als <strong class="highlight">Salt-and-Pepper-Rauschen</strong> bekannt.</li><li>Es äußert sich durch <strong class="highlight">vereinzelte, zufällig verteilte Pixel</strong>, die entweder den minimalen (0, schwarz, "pepper") oder den maximalen (255, weiß, "salt") Grauwert annehmen.</li><li>Die übrigen Pixel des Bildes bleiben unberührt.</li><li>Ursachen sind oft defekte Sensorzellen oder Fehler bei der Datenübertragung.</li></ul><p class="font-semibold mb-2">Beste Methode zur Entfernung: Medianfilter</p><p class="mb-3">Der <strong class="highlight">Medianfilter</strong> ist die effektivste Methode zur Entfernung von Impulsrauschen.</p><p class="font-semibold mb-2">Begründung:</p><ul class="list-disc list-inside pl-4"><li>Der Medianfilter ist ein <strong class="highlight">nicht-linearer Rangordnungsfilter</strong>.</li><li>Er betrachtet eine Nachbarschaft (z.B. 3x3), <strong class="highlight">sortiert alle Grauwerte</strong> dieser Nachbarschaft und wählt den <strong class="highlight">mittleren Wert (Median)</strong> aus.</li><li>Die extremen Werte (0 und 255) des Impulsrauschens landen bei der Sortierung immer am Anfang oder am Ende der Liste.</li><li>Sie werden daher <strong class="highlight">fast nie als Median ausgewählt</strong> und somit effektiv eliminiert, während die Kantenstruktur des Bildes gut erhalten bleibt.</li></ul></div>`
            },
            "q37": {
                question: "37. Vorgehen für: Führen Sie auf folgendem Binärbild B die morphologische Operation \"Opening\" mit dem Strukturelement \"8-Nachbarschaft\" und \"Zero-Padding\" aus.",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Vorgehen: Morphologische Öffnung (Opening)</h3><p class="mb-3">Die Operation <strong class="highlight">Opening</strong> besteht aus zwei Schritten: <strong>1. Erosion</strong>, gefolgt von <strong>2. Dilation</strong>.</p><p class="mb-2"><strong class="font-semibold">Strukturelement (SE):</strong> 3x3 Quadrat (entspricht 8-Nachbarschaft).</p><p class="mb-4"><strong class="font-semibold">Randbehandlung:</strong> Zero-Padding (Das Bild wird mit einem Rand aus Nullen umgeben).</p><p class="font-semibold mb-2">Schritt 1: Erosion</p><p class="mb-3">Ein Pixel im Ergebnisbild wird nur dann auf 1 gesetzt, wenn das <strong class="highlight">gesamte Strukturelement</strong> auf das Originalbild an dieser Position passt (alle 9 Pixel des SE müssen auf weißen Pixeln im Original liegen).</p><ul class="list-disc list-inside pl-4"><li>Dünne Linien und einzelne Pixel werden entfernt.</li><li>Objekte werden "dünner" gemacht oder "erodiert".</li><li>Kleine Störpixel ("salt noise") werden eliminiert.</li></ul><p class="font-semibold mt-4 mb-2">Schritt 2: Dilation (auf das erodierte Bild)</p><p class="mb-3">Ein Pixel im Ergebnisbild wird auf 1 gesetzt, wenn <strong class="highlight">mindestens ein Pixel</strong> des Strukturelements ein weißes Pixel im erodierten Bild überdeckt.</p><ul class="list-disc list-inside pl-4"><li>Die verbliebenen Strukturen werden wieder auf ihre ursprüngliche Größe (oder annähernd) erweitert.</li><li>Kleine Lücken in Objekten, die durch die Erosion entstanden sind, werden wieder geschlossen.</li></ul><p class="font-semibold mt-4 mb-2">Endergebnis der Öffnung:</p><p>Das Resultat ist, dass <strong class="highlight">kleine, isolierte Objekte entfernt</strong> und <strong class="highlight">feine Brücken zwischen Objekten durchtrennt</strong> wurden, während die Größe und Form der Hauptobjekte weitgehend erhalten geblieben ist.</p></div>`
            },
            "q38": {
                question: "38. Was sind die Voraussetzungen, damit eine Schwellenwertsegmentierung erfolgreich sein kann?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Voraussetzungen für erfolgreiche Schwellenwertsegmentierung</h3><p class="mb-3">Die Schwellenwertsegmentierung ist eine einfache, aber effektive Methode, um ein Bild in Vorder- und Hintergrund zu unterteilen. Ihr Erfolg hängt maßgeblich von folgenden Bedingungen ab:</p><ul class="list-disc list-inside pl-4 space-y-3"><li><strong class="font-semibold">Bimodales Histogramm:</strong> Die wichtigste Voraussetzung ist ein <strong class="highlight">deutliches Tal zwischen zwei Peaks</strong> im Histogramm des Bildes. Ein Peak repräsentiert die Grauwerte des Objekts, der andere die des Hintergrunds. Der Schwellenwert wird idealerweise in diesem Tal platziert.</li><li><strong class="font-semibold">Hoher Kontrast:</strong> Objekte und Hintergrund müssen sich <strong class="highlight">klar in ihrer Helligkeit unterscheiden</strong>. Geringer Kontrast führt zu überlappenden Peaks im Histogramm, was eine saubere Trennung unmöglich macht.</li><li><strong class="font-semibold">Gleichmäßige Ausleuchtung:</strong> Das Verfahren ist sehr empfindlich gegenüber <strong class="highlight">Helligkeitsschwankungen und Schatten</strong>. Eine ungleichmäßige Beleuchtung kann dazu führen, dass ein globaler Schwellenwert für das gesamte Bild nicht funktioniert. In solchen Fällen sind adaptive Schwellenwertverfahren notwendig.</li><li><strong class="font-semibold">Geringes Rauschen:</strong> Bildrauschen kann das Histogramm "verschmieren" und das Tal zwischen den Peaks auffüllen. Daher sollte das Bild idealerweise <strong class="highlight">vor der Segmentierung entrauscht</strong> werden (z.B. mit einem Gauß- oder Medianfilter).</li></ul></div>`
            },
            "q39": {
                question: "39. Warum eignet sich das JPEG-Verfahren eher weniger zur Kompression von Schwarz-Weiß-Bildern?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">JPEG-Kompression bei Schwarz-Weiß-Bildern</h3><p class="mb-3">Das JPEG-Verfahren eignet sich schlecht für typische Schwarz-Weiß-Bilder (z.B. gescannte Dokumente, technische Zeichnungen) aus folgendem Hauptgrund:</p><p class="font-semibold mb-2">Problem: Hohe Frequenzen an Kanten</p><ul class="list-disc list-inside mb-4 pl-4"><li>Schwarz-Weiß-Bilder bestehen fast ausschließlich aus <strong class="highlight">harten Kanten</strong> (Übergänge von 0 auf 255).</li><li>Im Frequenzraum entsprechen solche harten Kanten einer <strong class="highlight">Überlagerung sehr vieler hoher Frequenzen</strong>.</li><li>Der erste Schritt von JPEG, die <strong class="highlight">Diskrete Kosinustransformation (DCT)</strong>, wandelt die Bildblöcke in den Frequenzraum um. Bei einem Block mit einer Kante entstehen dabei viele von Null verschiedene Koeffizienten.</li><li>Der Kompressionsgewinn von JPEG basiert aber darauf, dass nach der DCT und Quantisierung <strong class="highlight">möglichst viele Koeffizienten zu Null werden</strong>. Dies ist bei Schwarz-Weiß-Bildern nicht der Fall. Die Transformation erzeugt eher mehr Daten als sie reduziert.</li></ul><p class="font-semibold mb-2">Bessere Alternativen:</p><p>Für Binärdaten sind verlustfreie Verfahren, die die räumliche Redundanz direkt ausnutzen, wesentlich effizienter:</p><ul class="list-disc list-inside pl-4"><li><strong class="highlight">Lauflängencodierung (RLE):</strong> Speichert die Anzahl aufeinanderfolgender gleicher Pixel (z.B. "150 weiße Pixel, dann 20 schwarze Pixel..."). Sehr effektiv für große einfarbige Flächen.</li><li><strong class="highlight">Huffman-Codierung:</strong> Kann direkt auf die Binärdaten angewendet werden, ist aber meist in Kombination mit RLE (wie bei FAX-Standards) am effektivsten.</li></ul></div>`
            },
            "q40": {
                question: "40. Begründen Sie mathematisch, warum der Fourierkoeffizient F(0,0) als mittlere Helligkeit interpretiert werden kann.",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Bedeutung des Fourierkoeffizienten F(0,0)</h3><p class="mb-3">Der Koeffizient $F(0,0)$, oft auch als <strong class="highlight">DC-Anteil</strong> (Gleichanteil) bezeichnet, repräsentiert die durchschnittliche Helligkeit des Bildes.</p><p class="font-semibold mb-2">Mathematische Herleitung:</p><p>1. Die allgemeine Formel für die 2D Diskrete Fouriertransformation (DFT) eines Bildes $f(m,n)$ der Größe $M \\times N$ lautet:</p>$$F(u,v) = \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} f(m,n) \\cdot e^{-i2\\pi(\\frac{um}{M} + \\frac{vn}{N})}$$<p class="mt-4">2. Um den spezifischen Koeffizienten $F(0,0)$ zu finden, setzen wir $u=0$ und $v=0$ in die Formel ein:</p>$$F(0,0) = \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} f(m,n) \\cdot e^{-i2\\pi(\\frac{0 \\cdot m}{M} + \\frac{0 \\cdot n}{N})}$$<p class="mt-4">3. Der Exponent des e-Terms wird dadurch zu Null:</p>$$F(0,0) = \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} f(m,n) \\cdot e^{0}$$<p class="mt-4">4. Da jede Zahl hoch Null (einschließlich $e^0$) gleich 1 ist, vereinfacht sich der Ausdruck zu:</p>$$F(0,0) = \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} f(m,n) \\cdot 1$$<p class="mt-4">5. Das Ergebnis ist schlicht die <strong class="highlight">Summe aller Pixel-Intensitätswerte</strong> $f(m,n)$ im gesamten Bild:</p>$$F(0,0) = \\sum_{\\text{alle Pixel}} \\text{Pixelwert}$$<p class="mt-4">Die <strong class="highlight">mittlere Helligkeit</strong> $\\overline{f}$ ist definiert als die Summe aller Pixelwerte geteilt durch die Anzahl der Pixel ($M \\times N$). Daher gilt:</p>$$\\text{Mittlere Helligkeit} = \\overline{f} = \\frac{1}{M \\cdot N} \\sum_{m=0}^{M-1} \\sum_{n=0}^{N-1} f(m,n) = \\frac{F(0,0)}{M \\cdot N}$$<p class="mt-4">Somit ist $F(0,0)$ direkt proportional zur mittleren Helligkeit des Bildes.</p></div>`
            },
            "q41": {
                question: "41. Wo sehen Sie den hauptsächlichen Einsatz des Medianfilters? Was ist dabei zu beachten?",
                answer: `<div class="text-left w-full"><h3 class="font-bold text-xl mb-3">Medianfilter: Einsatz und Besonderheiten</h3><p class="mb-3"><strong class="font-semibold">Hauptsächlicher Einsatz:</strong></p><p>Der Medianfilter ist das Mittel der Wahl zur <strong class="highlight">Entfernung von Impulsrauschen (Salt-and-Pepper Noise)</strong>. Dies ist eine Unterart des Rauschens, bei der einzelne Pixel zufällig den maximalen (weiß) oder minimalen (schwarz) Grauwert annehmen.</p><p class="font-semibold mt-4 mb-2">Warum er hier so gut funktioniert:</p><ul class="list-disc list-inside pl-4"><li>Er ist ein <strong class="highlight">Rangordnungsfilter</strong>, der nicht den Durchschnitt, sondern den Median einer Pixelnachbarschaft berechnet.</li><li>Die extremen Werte des Impulsrauschens werden bei der Sortierung an die Enden der Werteliste platziert und somit fast nie als Median ausgewählt.</li><li>Dadurch werden die Rauschpixel <strong class="highlight">effektiv eliminiert</strong>, ohne neue, unnatürliche Grauwerte zu erzeugen.</li></ul><p class="font-semibold mt-4 mb-2">Was ist zu beachten?</p><ul class="list-disc list-inside pl-4 space-y-3"><li><strong>Nicht-linear:</strong> Der Medianfilter ist ein nicht-linearer Filter. Das bedeutet, er kann <strong class="highlight">nicht im Frequenzraum</strong> durch eine Übertragungsfunktion beschrieben werden, sondern ist nur im Ortsraum definiert.</li><li><strong>Kantenerhalt:</strong> Er ist deutlich <strong class="highlight">kantenerhaltender</strong> als beispielsweise der Mittelwertfilter, da er keine neuen Grauwerte durch Mittelung erzeugt. Kanten bleiben scharf.</li><li><strong>Artefakte an Ecken und feinen Linien:</strong> Bei starker Anwendung oder großen Filtermasken kann der Medianfilter <strong class="highlight">scharfe Ecken abrunden</strong> und <strong class="highlight">sehr feine Linien (dünner als die halbe Maskengröße) entfernen</strong>.</li><li><strong>Rechenaufwand:</strong> Das Sortieren der Pixelwerte in jeder Nachbarschaft ist <strong class="highlight">rechenintensiver</strong> als die simple Addition und Division beim Mittelwertfilter.</li></ul></div>`
            }
        };


        let cardContent = { ...initialCardContent };
        let allFlashcards = [];
        let activeLevel = 'all';
        let currentDeck = [];
        let currentDeckIndex = 0;
        let isSearchActive = false;
        let searchResults = [];
        let searchIndex = 0;
        let voices = [];
        let currentSettings = { rate: 1, pitch: 1, autoRead: false };
        let utterance = null;
        let cardIdToDelete = null;
        let googleApiKey = null;
        let currentAudio = null;

        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);

        const flashcardContainer = $('#flashcard-container');
        const statsContainer = $('#stats-container');
        const correctBtn = $('#correct-btn');
        const wrongBtn = $('#wrong-btn');
        const prevBtn = $('#prev-btn');
        const nextBtn = $('#next-btn');
        const cardCounter = $('#card-counter');
        const answerButtons = $('#answer-buttons');
        const navigationContainer = $('#navigation-container');
        const searchInput = $('#search-input');
        const clearSearchBtn = $('#clear-search-btn');
        const apiKeyBanner = $('#api-key-banner');
        
        async function callGoogleTTS(text) {
             if (!googleApiKey) return;
             const apiUrl = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${googleApiKey}`;
             const payload = {
                 input: { text: text },
                 voice: { languageCode: 'de-DE', name: 'de-DE-Wavenet-F' },
                 audioConfig: { audioEncoding: 'MP3' }
             };
             try {
                 const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                 if (!response.ok) throw new Error(`Google TTS API request failed: ${response.status}`);
                 const result = await response.json();
                 if (result.audioContent) return `data:audio/mp3;base64,${result.audioContent}`;
                 return null;
             } catch (error) {
                 console.error("Error with Google TTS API:", error);
                 $('#api-key-status').textContent = "TTS-Anfrage fehlgeschlagen. Ist die Text-to-Speech API aktiviert?";
                 $('#api-key-status').className = 'text-xs text-center mt-2 h-4 text-red-600 dark:text-red-500';
                 return null;
             }
        }

        async function callGemini(prompt, isJson = false) {
            if (!googleApiKey) { openSettingsAndFocusKey(); throw new Error("Google API Key ist nicht festgelegt."); }
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${googleApiKey}`;
            let payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
                safetySettings: [ { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_ONLY_HIGH' }, { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_ONLY_HIGH' }, { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_ONLY_HIGH' }, { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_ONLY_HIGH' } ]
            };
            if (isJson) {
                 payload.generationConfig = {
                    responseMimeType: "application/json",
                    responseSchema: { type: "ARRAY", items: { type: "OBJECT", properties: { "question": { "type": "STRING" }, "answer": { "type": "STRING" } }, required: ["question", "answer"] } }
                }
            }
            try {
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) {
                    const errorBody = await response.json();
                    if (response.status === 400 && errorBody.error?.message.includes('API key not valid')) {
                         $('#api-key-status').textContent = "Der API-Schlüssel ist ungültig.";
                         $('#api-key-status').className = 'text-xs text-center mt-2 h-4 text-red-600 dark:text-red-500';
                         openSettingsAndFocusKey();
                    }
                    throw new Error(`API-Anfrage fehlgeschlagen: ${response.status} ${response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]) {
                    const text = result.candidates[0].content.parts[0].text;
                    return isJson ? JSON.parse(text) : text;
                }
                console.error("Unerwartete API-Antwortstruktur:", result);
                if (result.promptFeedback) throw new Error(`API-Anfrage blockiert: ${result.promptFeedback.blockReason}`);
                throw new Error('Kein Inhalt von der API zurückgegeben.');
            } catch (error) { console.error("Fehler beim Aufrufen der Gemini API:", error); throw error; }
        }

        function initializeCards() {
            const savedAICards = localStorage.getItem(AI_CARDS_KEY);
            if (savedAICards) try { Object.assign(cardContent, JSON.parse(savedAICards)); } catch (e) { console.error("Could not parse AI cards", e); }
            const savedData = localStorage.getItem(STORAGE_KEY);
            let progress = {};
            if (savedData) try { progress = JSON.parse(savedData); } catch (e) { console.error("Could not parse progress data", e); }
            allFlashcards = Object.keys(cardContent).map(id => ({ id, level: progress[id] || 1, isAI: id.startsWith('ai-') }));
        }

        function saveProgress() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(Object.fromEntries(allFlashcards.map(c => [c.id, c.level]))));
        }

        function updateStats() {
            const stats = allFlashcards.reduce((acc, card) => ({ ...acc, [card.level]: (acc[card.level] || 0) + 1 }), {});
            const aiCardsCount = allFlashcards.filter(c => c.isAI).length;
            statsContainer.innerHTML = `<div class="stats-controls-container">
                    <div data-level="all" class="stat-box ${activeLevel === 'all' ? 'active' : ''}">Alle (${allFlashcards.filter(c => c.level < 5 && !c.isAI).length})</div>
                    ${[1, 2, 3, 4, 5].map(level => `<div data-level="${level}" class="stat-box ${activeLevel == level ? 'active' : ''}">Stufe ${level}: <span class="font-bold">${stats[level] || 0}</span></div>`).join('')}
                    ${aiCardsCount > 0 ? `<div data-level="ai" class="stat-box ${activeLevel === 'ai' ? 'active' : ''}">Generiert (${aiCardsCount})</div>` : ''}
                    <button id="shuffle-btn" class="control-btn">Mischen</button>
                    <button id="reset-btn" class="control-btn bg-yellow-500 hover:bg-yellow-600 dark:bg-yellow-600 dark:hover:bg-yellow-700">Zurücksetzen</button>
                </div>`;
            $$('.stat-box').forEach(box => box.addEventListener('click', () => { activeLevel = box.dataset.level; updateStats(); updateDeck(false); }));
            $('#shuffle-btn').addEventListener('click', () => updateDeck(true));
            $('#reset-btn').addEventListener('click', openResetModal);
        }

        function updateDeck(shuffle = false) {
            let eligibleCards;
            if (activeLevel === 'ai') eligibleCards = allFlashcards.filter(card => card.isAI);
            else if (activeLevel !== 'all') eligibleCards = allFlashcards.filter(card => card.level === parseInt(activeLevel));
            else eligibleCards = allFlashcards.filter(card => card.level < 5 && !card.isAI);
            currentDeck = eligibleCards.map(card => card.id);
            if (shuffle) currentDeck.sort(() => Math.random() - 0.5);
            else currentDeck.sort((a, b) => cardContent[a].question.localeCompare(cardContent[b].question, undefined, { numeric: true }));
            currentDeckIndex = 0;
            showCard();
        }

        function showCard() {
            if (currentAudio) currentAudio.pause();
            speechSynthesis.cancel();
            let cardObject, content, cardId;
            const sourceDeck = isSearchActive ? searchResults : currentDeck.map(id => allFlashcards.find(c => c.id === id));
            const sourceIndex = isSearchActive ? searchIndex : currentDeckIndex;
            cardObject = sourceDeck[sourceIndex];
            
            if (cardObject) { cardId = cardObject.id; content = cardContent[cardId]; }
            
            if (!cardObject) {
                let message;
                if (isSearchActive) message = `Keine Ergebnisse für "${searchInput.value}" gefunden.`;
                else if (activeLevel === 'ai') message = googleApiKey ? 'Keine generierten Karten vorhanden. Erstelle welche mit dem ✨ Button!' : 'Bitte gib einen API-Schlüssel in den Einstellungen ein, um AI-Karten zu erstellen.';
                else if (activeLevel !== 'all' && activeLevel < 5) message = `Alle Karten in Stufe ${activeLevel} für diese Sitzung beantwortet!`;
                else message = allFlashcards.every(c => c.level === 5 || c.isAI) ? '🎉 Fantastisch! Du hast alle Karten gemeistert.' : 'Alle Karten für diese Sitzung beantwortet!';
                flashcardContainer.innerHTML = `<div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg flex flex-col items-center justify-center p-8 h-full"><h2 class="text-2xl font-bold text-indigo-600 dark:text-indigo-500 mb-4">Hinweis</h2><p class="text-lg text-gray-700 dark:text-gray-300 text-center">${message}</p></div>`;
                cardCounter.textContent = '';
                navigationContainer.style.display = 'none';
                answerButtons.style.display = 'none';
                return;
            }
            
            navigationContainer.style.display = 'flex';
            answerButtons.style.display = 'flex';
            
            const readIconHTML = `<span class="read-icon"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" /></svg></span>`;
            const readBtnHTMLFront = `<button onclick="speak(event, true)" class="read-aloud-btn p-2 rounded-full text-gray-500 dark:text-gray-400 focus:outline-none">${readIconHTML}</button>`;
            const readBtnHTMLBack = `<button onclick="speak(event, false)" class="read-aloud-btn p-2 rounded-full text-gray-500 dark:text-gray-400 focus:outline-none">${readIconHTML}</button>`;

            const explainBtnHTML = `<button onclick="explainSimply(event)" title="Einfach erklärt" class="absolute bottom-4 right-4 z-10 p-3 rounded-full bg-indigo-600 text-white shadow-lg hover:bg-indigo-700 focus:outline-none disabled:opacity-50 disabled:bg-gray-400 disabled:cursor-not-allowed transform hover:scale-110 transition-transform" ${!googleApiKey ? 'disabled' : ''}><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707m12.728 0l-.707.707M12 21v-1m0-10a3 3 0 013 3 3 3 0 01-3 3 3 3 0 01-3-3 3 3 0 013-3z"></path></svg></button>`;
            const deleteBtnHTML = cardObject.isAI ? `<button onclick="openDeleteModal(event, '${cardId}')" title="Karte löschen" class="absolute bottom-4 left-4 z-10 p-2 rounded-full text-gray-500 dark:text-gray-400 hover:bg-red-100 dark:hover:bg-red-900 hover:text-red-600 dark:hover:text-red-500 focus:outline-none"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>` : '';

            flashcardContainer.innerHTML = `
                <div id="flashcard" class="flashcard">
                    <div class="card-face card-front">
                        ${readBtnHTMLFront}
                        <div class="level-indicator ${cardObject.isAI ? 'level-ai' : 'level-normal'}">Stufe ${cardObject.level}</div>
                        <div class="card-content-wrapper"><h2 class="text-2xl lg:text-3xl font-bold text-center p-4">${content.question}</h2></div>
                    </div>
                    <div class="card-face card-back">
                        ${readBtnHTMLBack}
                        ${explainBtnHTML}
                        ${deleteBtnHTML}
                        <div class="level-indicator ${cardObject.isAI ? 'level-ai' : 'level-normal'}">Stufe ${cardObject.level}</div>
                        <div class="card-content-wrapper">${content.answer}</div>
                    </div>
                </div>`;
            
            cardCounter.textContent = `Karte ${sourceIndex + 1} / ${sourceDeck.length}`;

            $('#flashcard').addEventListener('click', (e) => {
                if (!e.target.closest('button')) {
                    const card = $('#flashcard');
                    card.classList.toggle('is-flipped');
                    if (currentSettings.autoRead && card.classList.contains('is-flipped')) setTimeout(() => speak(e, false), 300);
                }
            });
            renderMathInElement(flashcardContainer, { delimiters: [{ left: "$$", right: "$$", display: true }, { left: "$", right: "$", display: false }] });
            if (currentSettings.autoRead && !$('#flashcard').classList.contains('is-flipped')) setTimeout(() => speak(event, true), 300);
        }

        function handleAnswer(isCorrect) {
            const sourceDeck = isSearchActive ? searchResults : currentDeck.map(id => allFlashcards.find(c => c.id === id));
            const sourceIndex = isSearchActive ? searchIndex : currentDeckIndex;
            if (sourceDeck.length === 0) return;
            const cardObject = sourceDeck[sourceIndex];
            if (!cardObject) return;
            cardObject.level = isCorrect ? Math.min(5, cardObject.level + 1) : 1;
            saveProgress();
            if (!isSearchActive && activeLevel !== 'ai' && activeLevel < 5) {
                currentDeck.splice(currentDeckIndex, 1);
                if (currentDeckIndex >= currentDeck.length && currentDeck.length > 0) currentDeckIndex = 0;
            }
            if (isSearchActive) { if(searchResults.length > 0) searchIndex = (searchIndex + 1) % searchResults.length; }
            else { updateStats(); }
            showCard();
        }

        function openResetModal() {
            let title = "Alle Fortschritte zurücksetzen?", text = "Dadurch werden alle Karten auf Stufe 1 zurückgesetzt.";
            if (activeLevel !== 'all' && activeLevel !== 'ai') { title = `Fortschritt für Stufe ${activeLevel} zurücksetzen?`; text = `Dadurch werden alle Karten der Stufe ${activeLevel} auf Stufe 1 zurückgesetzt.`; }
            else if (activeLevel === 'ai') { title = "Generierte Karten zurücksetzen?"; text = "Dadurch wird der Fortschritt aller generierten Karten auf Stufe 1 zurückgesetzt."; }
            $('#reset-modal-title').textContent = title;
            $('#reset-modal-text').textContent = text;
            $('#reset-modal').classList.add('visible');
        }

        function resetProgress() {
            if (activeLevel === 'all') allFlashcards.forEach(c => { if (!c.isAI) c.level = 1; });
            else if (activeLevel === 'ai') allFlashcards.forEach(c => { if (c.isAI) c.level = 1; });
            else allFlashcards.forEach(c => { if (c.level === parseInt(activeLevel)) c.level = 1; });
            saveProgress();
            updateStats();
            $('#reset-modal').classList.remove('visible');
            updateDeck(false);
        }

        function performSearch() {
            const query = searchInput.value.toLowerCase().trim();
            isSearchActive = query.length > 0;
            clearSearchBtn.classList.toggle('hidden', !isSearchActive);
            statsContainer.classList.toggle('hidden', isSearchActive);
            if(isSearchActive) {
                searchResults = allFlashcards.filter(card => {
                    const content = cardContent[card.id];
                    return content.question.toLowerCase().includes(query) || (content.answer.replace(/<[^>]*>/g, ' ').toLowerCase().includes(query));
                });
                searchIndex = 0;
            } else { searchResults = []; }
            updateDeck(false);
        }

        function applyTheme(theme) {
            document.documentElement.classList.toggle('dark', theme === 'dark');
            $('#theme-toggle-dark-icon').classList.toggle('hidden', theme !== 'dark');
            $('#theme-toggle-light-icon').classList.toggle('hidden', theme === 'dark');
        }

        function setReadButtonState(isReading) {
            const icons = $$('.read-aloud-btn .read-icon');
            if (!icons || icons.length === 0) return;
            
            const stopIcon = `<svg class="w-6 h-6 animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" /><path stroke-linecap="round" stroke-linejoin="round" d="M9 9.563C9 9.252 9.252 9 9.563 9h4.874c.311 0 .563.252.563.563v4.874c0 .311-.252.563-.563.563H9.564A.562.562 0 0 1 9 14.437V9.564Z" /></svg>`;
            const playIcon = `<svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" /></svg>`;
            
            icons.forEach(icon => {
                icon.innerHTML = isReading ? stopIcon : playIcon;
            });
        }

        async function speak(event, isFront) {
            event?.stopPropagation();
            if (currentAudio?.played && !currentAudio.paused) { currentAudio.pause(); return; }
            speechSynthesis.cancel();
            
            const cardId = isSearchActive ? searchResults[searchIndex]?.id : currentDeck[currentDeckIndex];
            if (!cardId) return;
            
            const content = cardContent[cardId];
            const textToSpeak = (isFront ? content.question : content.answer).replace(/<[^>]*>/g, ' ').replace(/\$\$.*?\$\$/g, 'Formel').replace(/\$.*?\$/g, 'Formel');
            
            setReadButtonState(true);
            
            if (googleApiKey) {
                const audioSrc = await callGoogleTTS(textToSpeak);
                if (audioSrc) {
                    currentAudio = new Audio(audioSrc);
                    currentAudio.play().catch(e => console.error("Audio play failed:", e));
                    currentAudio.onended = () => setReadButtonState(false);
                    currentAudio.onpause = () => setReadButtonState(false);
                    return;
                }
            }
            
            utterance = new SpeechSynthesisUtterance(textToSpeak);
            utterance.voice = voices.find(v => v.lang.startsWith('de') && v.default) || voices.find(v => v.lang.startsWith('de'));
            utterance.pitch = currentSettings.pitch;
            utterance.rate = currentSettings.rate;
            utterance.onend = () => setReadButtonState(false);
            speechSynthesis.speak(utterance);
        }
        
        function loadApiKey() {
            googleApiKey = localStorage.getItem(API_KEY_STORAGE_KEY);
            if (googleApiKey) {
                $('#api-key-input').placeholder = "API-Schlüssel ist gespeichert";
                $('#api-key-status').textContent = "Schlüssel gespeichert. AI-Funktionen sind aktiv.";
                $('#api-key-status').className = 'text-xs text-center mt-2 h-4 text-green-600 dark:text-green-400';
            } else {
                $('#api-key-status').textContent = "Kein API-Schlüssel gefunden.";
                $('#api-key-status').className = 'text-xs text-center mt-2 h-4 text-yellow-600 dark:text-yellow-500';
                apiKeyBanner.classList.remove('hidden');
            }
            updateAIFeaturesActivation();
        }

        function saveApiKey() {
            const key = $('#api-key-input').value.trim();
            if (key) {
                googleApiKey = key;
                localStorage.setItem(API_KEY_STORAGE_KEY, key);
                $('#api-key-input').value = '';
                $('#api-key-status').textContent = "Schlüssel erfolgreich gespeichert!";
                $('#api-key-status').className = 'text-xs text-center mt-2 h-4 text-green-600 dark:text-green-400';
                apiKeyBanner.classList.add('hidden');
                updateAIFeaturesActivation();
            } else {
                $('#api-key-status').textContent = "Bitte gib einen gültigen Schlüssel ein.";
                $('#api-key-status').className = 'text-xs text-center mt-2 h-4 text-red-600 dark:text-red-500';
            }
        }
        
        function updateAIFeaturesActivation() {
            const isKeySet = !!googleApiKey;
            $$('#open-generate-modal-btn, #suggest-topic-btn, #generate-confirm-btn').forEach(el => { el.disabled = !isKeySet; el.title = isKeySet ? '' : 'Bitte API-Schlüssel in den Einstellungen festlegen.'; });
            if (flashcardContainer.innerHTML.trim() !== '') showCard();
        }
        
        function openSettingsAndFocusKey() { $('#settings-modal').classList.add('visible'); setTimeout(() => $('#api-key-input').focus(), 100); }

        async function explainSimply(event) {
            event.stopPropagation();
            $('#explanation-modal').classList.add('visible');
            $('#explanation-content').innerHTML = '<div class="flex justify-center items-center p-8"><div class="spinner"></div></div>';
            const cardId = isSearchActive ? searchResults[searchIndex].id : currentDeck[currentDeckIndex];
            const content = cardContent[cardId];
            const prompt = `Erkläre das folgende Konzept aus der digitalen Bildverarbeitung in einfachen Worten... Thema: "${content.question}"\nInhalt:\n${content.answer.replace(/<[^>]*>/g, ' ')}`;
            try {
                const explanation = await callGemini(prompt);
                $('#explanation-content').innerHTML = marked.parse(explanation);
            } catch (error) { $('#explanation-content').innerHTML = `<p class="text-red-500">Erklärung konnte nicht geladen werden: ${error.message}</p>`; }
        }

        function setupEventListeners() {
            correctBtn.addEventListener('click', () => handleAnswer(true));
            wrongBtn.addEventListener('click', () => handleAnswer(false));
            prevBtn.addEventListener('click', () => { isSearchActive ? (searchIndex = (searchIndex - 1 + searchResults.length) % searchResults.length) : (currentDeckIndex = (currentDeckIndex - 1 + currentDeck.length) % currentDeck.length); showCard(); });
            nextBtn.addEventListener('click', () => { isSearchActive ? (searchIndex = (searchIndex + 1) % searchResults.length) : (currentDeckIndex = (currentDeckIndex + 1) % currentDeck.length); showCard(); });
            $('#reset-confirm-btn').addEventListener('click', resetProgress);
            $('#theme-toggle').addEventListener('click', () => { const newTheme = document.documentElement.classList.toggle('dark') ? 'dark' : 'light'; localStorage.setItem(THEME_KEY, newTheme); applyTheme(newTheme); });
            searchInput.addEventListener('input', performSearch);
            clearSearchBtn.addEventListener('click', () => { searchInput.value = ''; performSearch(); });
            $('#close-api-banner').addEventListener('click', () => apiKeyBanner.classList.add('hidden'));
            $('#banner-settings-link').addEventListener('click', openSettingsAndFocusKey);
            $('#settings-btn').addEventListener('click', openSettingsAndFocusKey);
            $('#api-key-save-btn').addEventListener('click', saveApiKey);
            $('#api-key-input').addEventListener('keydown', e => e.key === 'Enter' && saveApiKey());
            $$('.modal-overlay').forEach(m => m.addEventListener('click', e => e.target === m && m.classList.remove('visible')));
            $$('.modal-close-btn, #reset-cancel-btn, #delete-cancel-btn, #generate-cancel-btn, #settings-close-btn, #explanation-close-btn-bottom').forEach(b => b.addEventListener('click', () => b.closest('.modal-overlay').classList.remove('visible')));
            $('#rate-slider').addEventListener('input', e => { currentSettings.rate = e.target.value; $('#rate-value').textContent = e.target.value; });
            $('#pitch-slider').addEventListener('input', e => { currentSettings.pitch = e.target.value; $('#pitch-value').textContent = e.target.value; });
            [ $('#rate-slider'), $('#pitch-slider') ].forEach(el => el.addEventListener('change', () => localStorage.setItem(SETTINGS_KEY, JSON.stringify(currentSettings))));
            $('#auto-read-checkbox').addEventListener('change', e => { currentSettings.autoRead = e.target.checked; localStorage.setItem(SETTINGS_KEY, JSON.stringify(currentSettings)); });
            $('#open-generate-modal-btn').addEventListener('click', () => { if (googleApiKey) $('#generate-modal').classList.add('visible'); else openSettingsAndFocusKey(); });
            $('#suggest-topic-btn').addEventListener('click', async () => { /* ... suggest topic logic ... */ });
            $('#generate-confirm-btn').addEventListener('click', async () => { /* ... generate cards logic ... */ });
            $('#delete-confirm-btn').addEventListener('click', () => { /* ... delete logic ... */ });
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Check if we're in an iframe and add appropriate class
            if (window !== window.parent) {
                document.body.classList.add('iframe-mode');
            }
            
            loadApiKey();
            const savedSettings = localStorage.getItem(SETTINGS_KEY);
            if(savedSettings) try { currentSettings = JSON.parse(savedSettings); } catch(e) {}
            $('#rate-slider').value = currentSettings.rate; $('#rate-value').textContent = currentSettings.rate;
            $('#pitch-slider').value = currentSettings.pitch; $('#pitch-value').textContent = currentSettings.pitch;
            $('#auto-read-checkbox').checked = currentSettings.autoRead;
            initializeCards();
            applyTheme(localStorage.getItem(THEME_KEY) || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'));
            updateStats();
            updateDeck(false);
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = () => { voices = speechSynthesis.getVoices(); };
            }
            setupEventListeners();
        });
        
        // Helper functions for modals and delete actions need to be defined in the global scope
        // because they are called via onclick attributes in the dynamically generated HTML.
        function openDeleteModal(event, cardId) {
            event.stopPropagation();
            cardIdToDelete = cardId;
            $('#delete-modal').classList.add('visible');
        }
    </script>
</body>
</html>
